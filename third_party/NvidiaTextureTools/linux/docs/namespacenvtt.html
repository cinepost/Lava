<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>nvtt: nvtt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvtt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nvtt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for all public non-macro NVTT fields.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_batch_list.html">BatchList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defining a list of inputs to be compressed.  <a href="structnvtt_1_1_batch_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_compression_options.html">CompressionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression options. This class describes the desired compression format and other compression settings.  <a href="structnvtt_1_1_compression_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression context.  <a href="structnvtt_1_1_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing all the input images from host memory. The image data is reordered by tiles.  <a href="structnvtt_1_1_c_p_u_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_cube_surface.html">CubeSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structnvtt_1_1_cube_surface.html" title="A CubeSurface is one level of a cube map texture. ">CubeSurface</a> is one level of a cube map texture.  <a href="structnvtt_1_1_cube_surface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_error_handler.html">ErrorHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable interface for handling errors.  <a href="structnvtt_1_1_error_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing all the input images from device memory. The image data is reordered by tiles.  <a href="structnvtt_1_1_g_p_u_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_output_handler.html">OutputHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable interface for outputting data.  <a href="structnvtt_1_1_output_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_output_options.html">OutputOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output Options.  <a href="structnvtt_1_1_output_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_ref_image.html">RefImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this structure to reference each of the input images.  <a href="structnvtt_1_1_ref_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface.html">Surface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A surface is one level of a 2D or 3D texture.  <a href="structnvtt_1_1_surface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_surface_set.html">SurfaceSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface-set struct for convenience of handling multi-level texture files such as DDS, currently only supporting reading.  <a href="structnvtt_1_1_surface_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structnvtt_1_1_timing_context.html" title="A TimingContext is a way to collect timing data from a number of functions, and report how much time ...">TimingContext</a> is a way to collect timing data from a number of functions, and report how much time each function took.  <a href="structnvtt_1_1_timing_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a77ad50b0ef658f079f5ec637a287fd6d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">Format</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dad70b3a5abe17d4e6cc1a731e4bee76a6">Format_RGB</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da1e4b5108b4c89f805f2efafd826b03d3">Format_RGBA</a> = Format_RGB, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da9ca8e3f8d05a0fae928ae309608ef722">Format_DXT1</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dad074d39474c02c1d4171d2545e3968b1">Format_DXT1a</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac40dd2ca7ea53576720b7c20e1704312">Format_DXT3</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daa2bd0a4fcc15b2a692a6d8929a43e4d3">Format_DXT5</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dae15335efd54def95c6df709b3f020999">Format_DXT5n</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7eb461737e0fc882a93255789c7cadec">Format_BC1</a> = Format_DXT1, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dad251519ccb2dcda1bc41e7cd1b2e1c4c">Format_BC1a</a> = Format_DXT1a, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da0b504e386c28119b49c6064a64452d66">Format_BC2</a> = Format_DXT3, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282">Format_BC3</a> = Format_DXT5, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da841bbc25f933d81b4a43c851c5440c64">Format_BC3n</a> = Format_DXT5n, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dadc47f6b455d3533d5d3bc7abd231a2fb">Format_BC4</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daf01d343dcafe84c2084a5a86344bf1db">Format_BC4S</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dab368e55b0d5dbffa54861a62db699526">Format_ATI2</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7e53438784904c341ff65d3ed8bac4af">Format_BC5</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dade3eb3f3d00102653de87f48a4c53b45">Format_BC5S</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dabf6dd404c065d8d9aa35266241771f80">Format_DXT1n</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dafae7a3d4517b2e6bb9ffc3b30c35112d">Format_CTX1</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da53a0a422d27f650216141a2b69419972">Format_BC6U</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da57afee5146cfce8914252efe38ee69af">Format_BC6S</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">Format_BC7</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da3623a3b6e315c7cd908dd4ea78b68c58">Format_BC3_RGBM</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dacd61083f3787f211cdc3e7d27acf0bcb">Format_ASTC_LDR_4x4</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daa462932902c3804af0974ea419728caa">Format_ASTC_LDR_5x4</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da69fa601cd97b38a974ad5a94a1f3f9a4">Format_ASTC_LDR_5x5</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dae16bc6c24bb5c12f5b1bdfcfda621e49">Format_ASTC_LDR_6x5</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7eaa6f0a5231f4803526021a8706578c">Format_ASTC_LDR_6x6</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da3a68b29ecfa982cccc6767d6689f0a5a">Format_ASTC_LDR_8x5</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dab7f9c4ca1719ae5e4eceb3ce0a2f8901">Format_ASTC_LDR_8x6</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dae931d404efcdffa4b2dbabf9fdf54228">Format_ASTC_LDR_8x8</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da697ca508a97e9e064f7434863e39f41e">Format_ASTC_LDR_10x5</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7625882a2047accb75e68e3c3aa10ccf">Format_ASTC_LDR_10x6</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da4c8c8b6ec09ff02cc4f3802b79ace3e0">Format_ASTC_LDR_10x8</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6daf8842b25b9be7ace43116e155dcd18a6">Format_ASTC_LDR_10x10</a>, 
<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da8aae371759244af41fe3e77e7a904d10">Format_ASTC_LDR_12x10</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac03f729d1aede99d35414fd9b524a41a">Format_ASTC_LDR_12x12</a>, 
<b>Format_Count</b>
<br />
 }<tr class="memdesc:a77ad50b0ef658f079f5ec637a287fd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported block-compression formats, including compressor variants.  <a href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a77ad50b0ef658f079f5ec637a287fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbc2d4c0396fc4e6d75d19e435c88ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88ed">PixelType</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda36283fd855802ab127337a9204a1abac">PixelType_UnsignedNorm</a> = 0, 
<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88edac5f45ced167de5441252bb48cedaae11">PixelType_SignedNorm</a> = 1, 
<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda6f44a7d0693e3706916061221bc76724">PixelType_UnsignedInt</a> = 2, 
<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda86f04728921c58b535e40d9b4e156123">PixelType_SignedInt</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88eda83f9ceb43bd9b001b835e39f08111db3">PixelType_Float</a> = 4, 
<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88edab8107297b020c703bc308794cbbdf6d5">PixelType_UnsignedFloat</a> = 5, 
<a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88edabb4c7c8a272083c0b14c7f8fdbf4f77b">PixelType_SharedExp</a> = 6
<br />
 }<tr class="memdesc:accbc2d4c0396fc4e6d75d19e435c88ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel value types.  <a href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88ed">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:accbc2d4c0396fc4e6d75d19e435c88ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4632cb59f63e6af3fc88fdfe5e44ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a5a4632cb59f63e6af3fc88fdfe5e44ee">Quality</a> { <b>Quality_Fastest</b>, 
<b>Quality_Normal</b>, 
<b>Quality_Production</b>, 
<b>Quality_Highest</b>
 }<tr class="memdesc:a5a4632cb59f63e6af3fc88fdfe5e44ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quality modes.  <a href="namespacenvtt.html#a5a4632cb59f63e6af3fc88fdfe5e44ee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a5a4632cb59f63e6af3fc88fdfe5e44ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c40c16cdcde3c6c3f2e7081777a146"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">WrapMode</a> { <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146ad11969ec5e66b90e4c7c55a2aa2542f0">WrapMode_Clamp</a>, 
<a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146aa974b2999b7a9ca5a0cbf5ebf52ecea9">WrapMode_Repeat</a>, 
<a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146a550cb72f50d0b0571a2db0badfb44083">WrapMode_Mirror</a>
 }<tr class="memdesc:a04c40c16cdcde3c6c3f2e7081777a146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap modes. Specifies how to handle coordinates outside the typical image range.  <a href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a04c40c16cdcde3c6c3f2e7081777a146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22da3a04bb7324cbd3919166b678b8e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22da3a04bb7324cbd3919166b678b8e2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a22da3a04bb7324cbd3919166b678b8e2">TextureType</a> { <b>TextureType_2D</b>, 
<b>TextureType_Cube</b>, 
<b>TextureType_3D</b>
 }<tr class="memdesc:a22da3a04bb7324cbd3919166b678b8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Texture types. Specifies the dimensionality of a texture. <br /></td></tr>
</td></tr>
<tr class="separator:a22da3a04bb7324cbd3919166b678b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea4cd82d5104d66e14f5524442c5f5e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">InputFormat</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5eaf8b3af0719535e2e45599d0b20a463d2">InputFormat_BGRA_8UB</a>, 
<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea2fcc1076f7eb98eb300757660fa8de07">InputFormat_BGRA_8SB</a>, 
<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea351131926eee5bf0c0d0ed706699e2f0">InputFormat_RGBA_16F</a>, 
<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea5c06b40c2edcfb0c948ebdc003c55a17">InputFormat_RGBA_32F</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5ea7d8245786e1f39d2a9b8fb6baa2005c8">InputFormat_R_32F</a>
<br />
 }<tr class="memdesc:a7ea4cd82d5104d66e14f5524442c5f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input formats. Used when creating an <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a> from an RGB/RGBA array.  <a href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7ea4cd82d5104d66e14f5524442c5f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d4701da3f4e6935956949dab69c479"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">MipmapFilter</a> { <a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479a5aed6ac6d80b602d7bd7d8fd2d977697">MipmapFilter_Box</a>, 
<a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479a484a5118a16886793c921a3f17c04a2c">MipmapFilter_Triangle</a>, 
<a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479ae4a53887c8ee06fd999f022eefa29c5e">MipmapFilter_Kaiser</a>
 }<tr class="memdesc:a28d4701da3f4e6935956949dab69c479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mipmap downsampling filters. Each of these can be customized using <code>filterWidth</code> and <code>params</code> when calling Surface::buildNextMipmap().  <a href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a28d4701da3f4e6935956949dab69c479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3607100ce561fdaa3859abd0f05878c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">ResizeFilter</a> { <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019">ResizeFilter_Box</a>, 
<a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7a86e98691c89dc3a4cd0b24bb2fd173cd">ResizeFilter_Triangle</a>, 
<a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7a6765919b82bb52e3384cd3b164347962">ResizeFilter_Kaiser</a>, 
<a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7ae014671bd84ab8296e2f1550f6afd7ee">ResizeFilter_Mitchell</a>
 }<tr class="memdesc:a3607100ce561fdaa3859abd0f05878c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Texture resizing filters.  <a href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3607100ce561fdaa3859abd0f05878c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673a22796ec42ae50e14ab1ed6906bd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> { <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5ae8a8417fa16eb6d657bec4a6a34a4eb5">RoundMode_None</a>, 
<a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5a6c20fa585fc05a9fa78907cb75fd192e">RoundMode_ToNextPowerOfTwo</a>, 
<a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5a62447741e676e7442edfa9a160f14be0">RoundMode_ToNearestPowerOfTwo</a>, 
<a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5aa11b8ae64e7890e5037d6984b96d14a5">RoundMode_ToPreviousPowerOfTwo</a>
 }<tr class="memdesc:a673a22796ec42ae50e14ab1ed6906bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extents rounding mode.  <a href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a673a22796ec42ae50e14ab1ed6906bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258d3a85ebeb5cf05c98ce3b2441b172"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">AlphaMode</a> { <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172a80b3682c42eec9a6dbc246872054c65a">AlphaMode_None</a>, 
<a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172ab064a6344180e25b06ff1e7cb7863d76">AlphaMode_Transparency</a>, 
<a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172a1e907653d2f7ea2020bd95938aa17694">AlphaMode_Premultiplied</a>
 }<tr class="memdesc:a258d3a85ebeb5cf05c98ce3b2441b172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alpha mode.  <a href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a258d3a85ebeb5cf05c98ce3b2441b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b50bb1a5bd8c44ab56092b30b9cd36"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">Error</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36aeb5d8ad9e386b13229cabf5ba1405475">Error_Unknown</a>, 
<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a7ae62389be2e2e29a7a1690b8721c105">Error_InvalidInput</a>, 
<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a0c76f5e3b3d2b2ab2dae1c3b7bd291e6">Error_UnsupportedFeature</a>, 
<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a61ea8e163d282921fbb20d9c6d165c6a">Error_CudaError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a050e9ac65add6839c261409762f63e60">Error_FileOpen</a>, 
<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36a272b79737f04552ad274898397e73f45">Error_FileWrite</a>, 
<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36aab5dbcdd40172c02fce91bf18ac46f36">Error_UnsupportedOutputFormat</a>, 
<b>Error_Count</b>
<br />
 }<tr class="memdesc:ad1b50bb1a5bd8c44ab56092b30b9cd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad1b50bb1a5bd8c44ab56092b30b9cd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ed02f7a03884673704a40ee13c7ea2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2">Container</a> { <a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2a0c37a8f503505acc0f2386d25f54ab02">Container_DDS</a>, 
<a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2a5a7d40cb9ce3544bf6c17fa93638abd0">Container_DDS10</a>
 }<tr class="memdesc:ad6ed02f7a03884673704a40ee13c7ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for encoded data.  <a href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad6ed02f7a03884673704a40ee13c7ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445e3b46e43013ef66771e98f7b1e0ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">NormalTransform</a> { <a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baa7a435baa677e410f036ae06441229333">NormalTransform_Orthographic</a>, 
<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baac7ed9d9e81f80b4e11e1f53ab4f6f0f9">NormalTransform_Stereographic</a>, 
<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baa80b2a507b4e75a1febccfb2044cd86c8">NormalTransform_Paraboloid</a>, 
<a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0baa99c18c7689a8117272ab957e3bd78a4a">NormalTransform_Quartic</a>
 }<tr class="memdesc:a445e3b46e43013ef66771e98f7b1e0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y).  <a href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a445e3b46e43013ef66771e98f7b1e0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30709ef62a9d666f2be7f34cce8e3b94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">ToneMapper</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ae75755a83e2455024daa028f9997e142">ToneMapper_Linear</a>, 
<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94a4eac0b21fc9b9abaa609aaccbc8b692d">ToneMapper_Reinhard</a>, 
<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ae212ae6b6b95ef74d99e8c294f0582a4">ToneMapper_Reindhart</a> = ToneMapper_Reinhard, 
<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94a88b4b1bc1882ee68b7148e3e36fe155f">ToneMapper_Halo</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ab9ee3d3f346369d1097532952c3f0baf">ToneMapper_Lightmap</a>
<br />
 }<tr class="memdesc:a30709ef62a9d666f2be7f34cce8e3b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tone mapping functions.  <a href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a30709ef62a9d666f2be7f34cce8e3b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447d53023355eb2e39e3e9a9a9b9d8dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dc">CubeLayout</a> { <br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca707896e6ec737f4b3a763146d7b33702">CubeLayout_VerticalCross</a>, 
<a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca3fb7abb18cf90ada89e7285dc1f03422">CubeLayout_HorizontalCross</a>, 
<a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca24b818d2b111932259f02aa69b52973a">CubeLayout_Column</a>, 
<a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dca24e62c1313b8ffe4c6ddc01aef5727df">CubeLayout_Row</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dcabf6eed2e38bb04ec6e660b136fede3da">CubeLayout_LatitudeLongitude</a>
<br />
 }<tr class="memdesc:a447d53023355eb2e39e3e9a9a9b9d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how to fold or unfold a cube map from or to a 2D texture.  <a href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a447d53023355eb2e39e3e9a9a9b9d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffe2adb946ca4eeae692ef547d57ca6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6">EdgeFixup</a> { <a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6affcf62e8e27e7351dce5c92908419767">EdgeFixup_None</a>, 
<a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6aeda3d9a01b5bcf73994c5ebcc52c62d5">EdgeFixup_Stretch</a>, 
<a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6abbcabb8211cceed5c1074b98d8575e4b">EdgeFixup_Warp</a>, 
<a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6a424f99e9f5ca67b49765dec421c8c27f">EdgeFixup_Average</a>
 }<tr class="memdesc:acffe2adb946ca4eeae692ef547d57ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use EdgeFixup_None if unsure; this affects how certain cube surface processing algorithms work.  <a href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acffe2adb946ca4eeae692ef547d57ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae939a4f095a98e5176153b81dba28321"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321">ValueType</a> { <b>UINT8</b>, 
<b>SINT8</b>, 
<b>FLOAT32</b>
 }</td></tr>
<tr class="separator:ae939a4f095a98e5176153b81dba28321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069e6423013efdad8fef5221e4266aba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a069e6423013efdad8fef5221e4266aba"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a069e6423013efdad8fef5221e4266aba">ChannelOrder</a> { <br />
&#160;&#160;<b>Red</b> = 0, 
<b>Green</b> = 1, 
<b>Blue</b> = 2, 
<b>Alpha</b> = 3, 
<br />
&#160;&#160;<b>Zero</b> = 4, 
<b>One</b> = 5
<br />
 }<tr class="memdesc:a069e6423013efdad8fef5221e4266aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of channels for defining a swizzling. <br /></td></tr>
</td></tr>
<tr class="separator:a069e6423013efdad8fef5221e4266aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa1ae97a643706ccf2940c94e3ca622fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1ae97a643706ccf2940c94e3ca622fd"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aa1ae97a643706ccf2940c94e3ca622fd">errorString</a> (<a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">Error</a> e)</td></tr>
<tr class="memdesc:aa1ae97a643706ccf2940c94e3ca622fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string for the given error code. <br /></td></tr>
<tr class="separator:aa1ae97a643706ccf2940c94e3ca622fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228e276da2093484610fa62a9ec4ee93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a228e276da2093484610fa62a9ec4ee93"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a228e276da2093484610fa62a9ec4ee93">version</a> ()</td></tr>
<tr class="memdesc:a228e276da2093484610fa62a9ec4ee93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return NVTT version. <br /></td></tr>
<tr class="separator:a228e276da2093484610fa62a9ec4ee93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a3afaec760ccfaddbc0d41a30ea3b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5a3afaec760ccfaddbc0d41a30ea3b4"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad5a3afaec760ccfaddbc0d41a30ea3b4">rmsError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ad5a3afaec760ccfaddbc0d41a30ea3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:ad5a3afaec760ccfaddbc0d41a30ea3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b64d4539ee2f98379249975d2b277c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91b64d4539ee2f98379249975d2b277c"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a91b64d4539ee2f98379249975d2b277c">rmsAlphaError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a91b64d4539ee2f98379249975d2b277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a91b64d4539ee2f98379249975d2b277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e0978c5e0f8676cc591d2efdb782e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21e0978c5e0f8676cc591d2efdb782e9"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a21e0978c5e0f8676cc591d2efdb782e9">cieLabError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a21e0978c5e0f8676cc591d2efdb782e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a21e0978c5e0f8676cc591d2efdb782e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc944623c193bb0a1f8679a6f44a78e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc944623c193bb0a1f8679a6f44a78e5"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#abc944623c193bb0a1f8679a6f44a78e5">angularError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:abc944623c193bb0a1f8679a6f44a78e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:abc944623c193bb0a1f8679a6f44a78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1781708d38918b6eda9165fb5f9c10c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1781708d38918b6eda9165fb5f9c10c1"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a1781708d38918b6eda9165fb5f9c10c1">diff</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, float scale, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a1781708d38918b6eda9165fb5f9c10c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a1781708d38918b6eda9165fb5f9c10c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bcafcdac02a84ac84306a758276b39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37bcafcdac02a84ac84306a758276b39"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a37bcafcdac02a84ac84306a758276b39">rmsToneMappedError</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;reference, const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, float exposure, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a37bcafcdac02a84ac84306a758276b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image comparison and error measurement functions. (New in NVTT 2.1) <br /></td></tr>
<tr class="separator:a37bcafcdac02a84ac84306a758276b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3181d618054f0b1591e01a342136b6b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3181d618054f0b1591e01a342136b6b7"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3181d618054f0b1591e01a342136b6b7">histogram</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, int width, int height, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a3181d618054f0b1591e01a342136b6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate histogram from surface. <br /></td></tr>
<tr class="separator:a3181d618054f0b1591e01a342136b6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b39014308319e64f6cb72ee5b0219fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b39014308319e64f6cb72ee5b0219fe"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> <a class="el" href="structnvtt_1_1_surface.html">Surface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a2b39014308319e64f6cb72ee5b0219fe">histogram</a> (const <a class="el" href="structnvtt_1_1_surface.html">Surface</a> &amp;img, float minRange, float maxRange, int width, int height, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a2b39014308319e64f6cb72ee5b0219fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate histogram from surface. <br /></td></tr>
<tr class="separator:a2b39014308319e64f6cb72ee5b0219fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aebd76a0eef81407c40b5b93ee7c10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73aebd76a0eef81407c40b5b93ee7c10"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10">getTargetExtent</a> (int *width, int *height, int *depth, int maxExtent, <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">RoundMode</a> roundMode, <a class="el" href="namespacenvtt.html#a22da3a04bb7324cbd3919166b678b8e2">TextureType</a> textureType, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:a73aebd76a0eef81407c40b5b93ee7c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geting the target extent for round-mode and texture-type. (New in NVTT 3.0) <br /></td></tr>
<tr class="separator:a73aebd76a0eef81407c40b5b93ee7c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f0d070b80d740b949710df7e9ca361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f0d070b80d740b949710df7e9ca361"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad3f0d070b80d740b949710df7e9ca361">countMipmaps</a> (int w, int h, int d, <a class="el" href="structnvtt_1_1_timing_context.html">TimingContext</a> *tc=0)</td></tr>
<tr class="memdesc:ad3f0d070b80d740b949710df7e9ca361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the count of mipmaps given width, height, depth. (New in NVTT 3.0) <br /></td></tr>
<tr class="separator:ad3f0d070b80d740b949710df7e9ca361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e1ba1bbab69167fca20f080ca9ce8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07e1ba1bbab69167fca20f080ca9ce8e"></a>
<a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a07e1ba1bbab69167fca20f080ca9ce8e">isCudaSupported</a> ()</td></tr>
<tr class="memdesc:a07e1ba1bbab69167fca20f080ca9ce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if CUDA is supported by the run-time environment. <br /></td></tr>
<tr class="separator:a07e1ba1bbab69167fca20f080ca9ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4331c366610258762f80c8a3d7ee6910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910">useCurrentDevice</a> ()</td></tr>
<tr class="memdesc:a4331c366610258762f80c8a3d7ee6910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells NVTT to always use an application-set device rather than selecting its own.  <a href="#a4331c366610258762f80c8a3d7ee6910">More...</a><br /></td></tr>
<tr class="separator:a4331c366610258762f80c8a3d7ee6910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bd68f7ce315c0c26124793512bc6ed"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a05bd68f7ce315c0c26124793512bc6ed">nvtt_encode_bc1</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a05bd68f7ce315c0c26124793512bc6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e0e41149b87bd6c5d3f327ac7a0a97"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aa9e0e41149b87bd6c5d3f327ac7a0a97">nvtt_encode_bc1</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aa9e0e41149b87bd6c5d3f327ac7a0a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3ed1c285fc5e6c146cc9de88937bb"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a5bd3ed1c285fc5e6c146cc9de88937bb">nvtt_encode_bc1a</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a5bd3ed1c285fc5e6c146cc9de88937bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eefb6c30a92e72d297f3bf2fe39f10"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a61eefb6c30a92e72d297f3bf2fe39f10">nvtt_encode_bc1a</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a61eefb6c30a92e72d297f3bf2fe39f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb08b8c7f7030e7473187ff5e986294f"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#abb08b8c7f7030e7473187ff5e986294f">nvtt_encode_bc2</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:abb08b8c7f7030e7473187ff5e986294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae6bd44be0539af54582d5dd5aa88a1"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a2ae6bd44be0539af54582d5dd5aa88a1">nvtt_encode_bc2</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a2ae6bd44be0539af54582d5dd5aa88a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac335a276d5f79af2a762d76988e661ad"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ac335a276d5f79af2a762d76988e661ad">nvtt_encode_bc3</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool fast_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ac335a276d5f79af2a762d76988e661ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad95872eab2e29b5b4a7721c4a2b961"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aaad95872eab2e29b5b4a7721c4a2b961">nvtt_encode_bc3</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aaad95872eab2e29b5b4a7721c4a2b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82056d5ee5c0f852135d8cd6bab149e"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ab82056d5ee5c0f852135d8cd6bab149e">nvtt_encode_bc3n</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, int qualityLevel, void *output, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ab82056d5ee5c0f852135d8cd6bab149e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69901604f7f6e6e1acb0486ad5db001"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ad69901604f7f6e6e1acb0486ad5db001">nvtt_encode_bc3_rgbm</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, void *output, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ad69901604f7f6e6e1acb0486ad5db001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c370ed199a91ca69c4c01c9f6daed39"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a7c370ed199a91ca69c4c01c9f6daed39">nvtt_encode_bc4</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a7c370ed199a91ca69c4c01c9f6daed39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76314c0b925a24e3f509e4a212668ae"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aa76314c0b925a24e3f509e4a212668ae">nvtt_encode_bc4</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aa76314c0b925a24e3f509e4a212668ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a4c506eb1c3b5ad89249ef3e8e340"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ab15a4c506eb1c3b5ad89249ef3e8e340">nvtt_encode_bc4s</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ab15a4c506eb1c3b5ad89249ef3e8e340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e7a48139329817c6b6acc3ae875c03"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ae3e7a48139329817c6b6acc3ae875c03">nvtt_encode_bc4s</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ae3e7a48139329817c6b6acc3ae875c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f678e13767228c68dfcad1da61e8b7d"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a2f678e13767228c68dfcad1da61e8b7d">nvtt_encode_ati2</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a2f678e13767228c68dfcad1da61e8b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f3f5de7cdefa79e31b095384b6e14"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a393f3f5de7cdefa79e31b095384b6e14">nvtt_encode_ati2</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a393f3f5de7cdefa79e31b095384b6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96f1d819b4c61b42d537c102080c32"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a0c96f1d819b4c61b42d537c102080c32">nvtt_encode_bc5</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a0c96f1d819b4c61b42d537c102080c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfc0444515b1304ab9a1cb6eb9ff5b8"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3dfc0444515b1304ab9a1cb6eb9ff5b8">nvtt_encode_bc5</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a3dfc0444515b1304ab9a1cb6eb9ff5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d632aa6c550b8b461f4343125fe77"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a7e4d632aa6c550b8b461f4343125fe77">nvtt_encode_bc5s</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a7e4d632aa6c550b8b461f4343125fe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ea7d013fca07b16f48745ad67b1e21"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#ac3ea7d013fca07b16f48745ad67b1e21">nvtt_encode_bc5s</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:ac3ea7d013fca07b16f48745ad67b1e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc828476883ed40499d01622d2a0873f"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#adc828476883ed40499d01622d2a0873f">nvtt_encode_bc7</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, bool imageHasAlpha, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:adc828476883ed40499d01622d2a0873f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dbdb09bbe3f2702bad846d90b69578"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a80dbdb09bbe3f2702bad846d90b69578">nvtt_encode_bc7</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, bool imageHasAlpha, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a80dbdb09bbe3f2702bad846d90b69578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd712c6a68534c161e2e20fa3967663"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#aebd712c6a68534c161e2e20fa3967663">nvtt_encode_bc6h</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, bool slow_mode, bool is_signed, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:aebd712c6a68534c161e2e20fa3967663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74857405343d8148e3aa8a840f5d9c1e"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a74857405343d8148e3aa8a840f5d9c1e">nvtt_encode_bc6h</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, bool is_signed, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a74857405343d8148e3aa8a840f5d9c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5eb0a19f8d66f6c9f5cf33f335c32f"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a3c5eb0a19f8d66f6c9f5cf33f335c32f">nvtt_encode_astc</a> (const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;input, int qualityLevel, bool imageHasAlpha, void *output, bool useGpu=false, bool to_device_mem=false, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a3c5eb0a19f8d66f6c9f5cf33f335c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b2a51a1949426c7f860c52c7561b97"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvtt.html#a25b2a51a1949426c7f860c52c7561b97">nvtt_encode_astc</a> (const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;input, int qualityLevel, bool imageHasAlpha, void *output, bool to_device_mem=true, <a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *tc=nullptr)</td></tr>
<tr class="separator:a25b2a51a1949426c7f860c52c7561b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all public non-macro NVTT fields. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a258d3a85ebeb5cf05c98ce3b2441b172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a258d3a85ebeb5cf05c98ce3b2441b172">nvtt::AlphaMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alpha mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a258d3a85ebeb5cf05c98ce3b2441b172a80b3682c42eec9a6dbc246872054c65a"></a>AlphaMode_None&#160;</td><td class="fielddoc">
<p>This image has no alpha. The alpha channel will be ignored in some forms of compression. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a258d3a85ebeb5cf05c98ce3b2441b172ab064a6344180e25b06ff1e7cb7863d76"></a>AlphaMode_Transparency&#160;</td><td class="fielddoc">
<p>Alpha represents opacity; for instance, (r, g, b, 0.5) is a 50% opaque (r, g, b) color. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a258d3a85ebeb5cf05c98ce3b2441b172a1e907653d2f7ea2020bd95938aa17694"></a>AlphaMode_Premultiplied&#160;</td><td class="fielddoc">
<p>Colors are stored using premultiplied alpha: (a*r, a*g, a*b, a) is an (r, g, b) color with an opacity of a. This is mostly for tracking purposes; compressors only distinguish between AlphaMode_None and AlphaMode_Transparency. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad6ed02f7a03884673704a40ee13c7ea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#ad6ed02f7a03884673704a40ee13c7ea2">nvtt::Container</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container type for encoded data. </p>
<dl class="section note"><dt>Note</dt><dd>For DDS containers, NVTT stores some additional data in the <code>reserved[]</code> fields to allow consumers to detect writer versions.<ul>
<li><code>reserved[7]</code> is the FourCC code "UVER", and <code>reserved[8]</code> stores a version number that can be set by the user.</li>
<li><code>reserved[9]</code> is the FourCC code "NVTT", and <code>reserved[10]</code> is the NVTT writer version (which isn't necessarily the same as <code><a class="el" href="namespacenvtt.html#a228e276da2093484610fa62a9ec4ee93" title="Return NVTT version. ">nvtt::version()</a></code>).</li>
</ul>
</dd>
<dd>
For DDS containers, NVTT also extends the <code>dwFlags</code> field with two more flags.<ul>
<li><code>DDPF_SRGB</code> (<code>0x40000000U</code>) indicates that the texture uses an sRGB transfer function. Note that most readers will ignore this and instead guess the transfer function from the format.</li>
<li><code>DDPF_NORMAL</code> (<code>0x80000000U</code>) indicates that the texture is a normal map. </li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad6ed02f7a03884673704a40ee13c7ea2a0c37a8f503505acc0f2386d25f54ab02"></a>Container_DDS&#160;</td><td class="fielddoc">
<p>DDS without the DX10 header extension. Compatible with legacy readers, but doesn't support BC6 or BC7. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad6ed02f7a03884673704a40ee13c7ea2a5a7d40cb9ce3544bf6c17fa93638abd0"></a>Container_DDS10&#160;</td><td class="fielddoc">
<p>DDS without the DX10 header. Supports BC6 and BC7, but may be unreadable by legacy readers. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a447d53023355eb2e39e3e9a9a9b9d8dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a447d53023355eb2e39e3e9a9a9b9d8dc">nvtt::CubeLayout</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies how to fold or unfold a cube map from or to a 2D texture. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a447d53023355eb2e39e3e9a9a9b9d8dca707896e6ec737f4b3a763146d7b33702"></a>CubeLayout_VerticalCross&#160;</td><td class="fielddoc">
<p>Unfolds into a 3*edgeLength (width) x 4*edgeLength texture, laid out as follows: ``` 2 140 3 5 ``` Face 5 is rotated 180 degrees. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a447d53023355eb2e39e3e9a9a9b9d8dca3fb7abb18cf90ada89e7285dc1f03422"></a>CubeLayout_HorizontalCross&#160;</td><td class="fielddoc">
<p>Unfolds into a 4*edgeLength (width) x 3*edgeLength texture, laid out as follows: ``` 2 1405 3 ``` Face 5 is rotated 180 degrees. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a447d53023355eb2e39e3e9a9a9b9d8dca24b818d2b111932259f02aa69b52973a"></a>CubeLayout_Column&#160;</td><td class="fielddoc">
<p>Writes each face in order into a column layout, like this: ``` 0 1 2 3 4 5 ``` </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a447d53023355eb2e39e3e9a9a9b9d8dca24e62c1313b8ffe4c6ddc01aef5727df"></a>CubeLayout_Row&#160;</td><td class="fielddoc">
<p>Writes each face in order into a row layout, like this: ``` 012345 ``` </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a447d53023355eb2e39e3e9a9a9b9d8dcabf6eed2e38bb04ec6e660b136fede3da"></a>CubeLayout_LatitudeLongitude&#160;</td><td class="fielddoc">
<p>Same as CubeLayout_VerticalCross. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="acffe2adb946ca4eeae692ef547d57ca6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#acffe2adb946ca4eeae692ef547d57ca6">nvtt::EdgeFixup</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use EdgeFixup_None if unsure; this affects how certain cube surface processing algorithms work. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="acffe2adb946ca4eeae692ef547d57ca6affcf62e8e27e7351dce5c92908419767"></a>EdgeFixup_None&#160;</td><td class="fielddoc">
<p>No effect. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acffe2adb946ca4eeae692ef547d57ca6aeda3d9a01b5bcf73994c5ebcc52c62d5"></a>EdgeFixup_Stretch&#160;</td><td class="fielddoc">
<p>Slightly stretches and shifts the coordinate systems cosinePowerFilter() and fastResample() use. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acffe2adb946ca4eeae692ef547d57ca6abbcabb8211cceed5c1074b98d8575e4b"></a>EdgeFixup_Warp&#160;</td><td class="fielddoc">
<p>Applies a cubic warp to each face's coordinate system in cosinePowerFilter() and fastResample(), warping texels closer to edges more. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acffe2adb946ca4eeae692ef547d57ca6a424f99e9f5ca67b49765dec421c8c27f"></a>EdgeFixup_Average&#160;</td><td class="fielddoc">
<p>Currently unimplemented. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#ad1b50bb1a5bd8c44ab56092b30b9cd36">nvtt::Error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_error_handler.html" title="Inheritable interface for handling errors. ">nvtt::ErrorHandler</a> </dd>
<dd>
<a class="el" href="namespacenvtt.html#aa1ae97a643706ccf2940c94e3ca622fd" title="Return string for the given error code. ">errorString()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36aeb5d8ad9e386b13229cabf5ba1405475"></a>Error_Unknown&#160;</td><td class="fielddoc">
<p>Unknown error. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36a7ae62389be2e2e29a7a1690b8721c105"></a>Error_InvalidInput&#160;</td><td class="fielddoc">
<p>The input to the function was invalid (for instance, a negative size). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36a0c76f5e3b3d2b2ab2dae1c3b7bd291e6"></a>Error_UnsupportedFeature&#160;</td><td class="fielddoc">
<p>Unsupported feature. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36a61ea8e163d282921fbb20d9c6d165c6a"></a>Error_CudaError&#160;</td><td class="fielddoc">
<p>CUDA reported an error during an operation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36a050e9ac65add6839c261409762f63e60"></a>Error_FileOpen&#160;</td><td class="fielddoc">
<p>I/O error attempting to open the given file. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36a272b79737f04552ad274898397e73f45"></a>Error_FileWrite&#160;</td><td class="fielddoc">
<p>I/O error attempting to write to the given file. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1b50bb1a5bd8c44ab56092b30b9cd36aab5dbcdd40172c02fce91bf18ac46f36"></a>Error_UnsupportedOutputFormat&#160;</td><td class="fielddoc">
<p>The chosen container does not support the requested format (for instance, attempting to store BC7 data in a DDS file without the DX10 header.) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d">nvtt::Format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported block-compression formats, including compressor variants. </p>
<p>That is:</p><ul>
<li>'DXT1' is a format, 'DXT1a' and 'DXT1n' are DXT1 compressors.</li>
<li>'DXT3' is a format, 'DXT3n' is a DXT3 compressor. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dad70b3a5abe17d4e6cc1a731e4bee76a6"></a>Format_RGB&#160;</td><td class="fielddoc">
<p>Linear RGB format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da1e4b5108b4c89f805f2efafd826b03d3"></a>Format_RGBA&#160;</td><td class="fielddoc">
<p>Linear RGBA format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da9ca8e3f8d05a0fae928ae309608ef722"></a>Format_DXT1&#160;</td><td class="fielddoc">
<p>DX9 - DXT1 format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dad074d39474c02c1d4171d2545e3968b1"></a>Format_DXT1a&#160;</td><td class="fielddoc">
<p>DX9 - DXT1 with binary alpha. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dac40dd2ca7ea53576720b7c20e1704312"></a>Format_DXT3&#160;</td><td class="fielddoc">
<p>DX9 - DXT3 format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6daa2bd0a4fcc15b2a692a6d8929a43e4d3"></a>Format_DXT5&#160;</td><td class="fielddoc">
<p>DX9 - DXT5 format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dae15335efd54def95c6df709b3f020999"></a>Format_DXT5n&#160;</td><td class="fielddoc">
<p>DX9 - DXT5 normal format. Stores a normal (x, y, z) as (R, G, B, A) = (1, y, 0, x). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da7eb461737e0fc882a93255789c7cadec"></a>Format_BC1&#160;</td><td class="fielddoc">
<p>DX10 - BC1 (DXT1) format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dad251519ccb2dcda1bc41e7cd1b2e1c4c"></a>Format_BC1a&#160;</td><td class="fielddoc">
<p>DX10 - BC1 (DXT1) format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da0b504e386c28119b49c6064a64452d66"></a>Format_BC2&#160;</td><td class="fielddoc">
<p>DX10 - BC2 (DXT3) format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282"></a>Format_BC3&#160;</td><td class="fielddoc">
<p>DX10 - BC3 (DXT5) format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da841bbc25f933d81b4a43c851c5440c64"></a>Format_BC3n&#160;</td><td class="fielddoc">
<p>DX10 - BC3 (DXT5) normal format for improved compression, storing a normal (x, y, z) as (1, y, 0, x). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dadc47f6b455d3533d5d3bc7abd231a2fb"></a>Format_BC4&#160;</td><td class="fielddoc">
<p>DX10 - BC4U (ATI1) format (one channel, unsigned) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6daf01d343dcafe84c2084a5a86344bf1db"></a>Format_BC4S&#160;</td><td class="fielddoc">
<p>DX10 - BC4S format (one channel, signed) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dab368e55b0d5dbffa54861a62db699526"></a>Format_ATI2&#160;</td><td class="fielddoc">
<p>DX10 - ATI2 format, similar to BC5U, channel order GR instead of RG. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da7e53438784904c341ff65d3ed8bac4af"></a>Format_BC5&#160;</td><td class="fielddoc">
<p>DX10 - BC5U format (two channels, unsigned) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dade3eb3f3d00102653de87f48a4c53b45"></a>Format_BC5S&#160;</td><td class="fielddoc">
<p>DX10 - BC5S format (two channels, signed) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dabf6dd404c065d8d9aa35266241771f80"></a>Format_DXT1n&#160;</td><td class="fielddoc">
<p>Not supported. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dafae7a3d4517b2e6bb9ffc3b30c35112d"></a>Format_CTX1&#160;</td><td class="fielddoc">
<p>Not supported. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da53a0a422d27f650216141a2b69419972"></a>Format_BC6U&#160;</td><td class="fielddoc">
<p>DX10 - BC6 format (three-channel HDR, unsigned) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da57afee5146cfce8914252efe38ee69af"></a>Format_BC6S&#160;</td><td class="fielddoc">
<p>DX10 - BC6 format (three-channel HDR, signed) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b"></a>Format_BC7&#160;</td><td class="fielddoc">
<p>DX10 - BC7 format (four channels, UNORM) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da3623a3b6e315c7cd908dd4ea78b68c58"></a>Format_BC3_RGBM&#160;</td><td class="fielddoc">
<p>DX10 - BC3(DXT5) - using a magnitude encoding to approximate three-channel HDR data in four UNORM channels. The input should be in the range [0,1], and this should give more accurate values closer to 0. On most devices, consider using BC6 instead.</p>
<p>To decompress this format, decompress it like a standard BC3 texture, then compute <code>(R, G, B)</code> from <code>(r, g, b, m)</code> using <code>fromRGBM()</code> with <code>range = 1</code> and <code>threshold = 0.25</code>:</p>
<p><code>M = m * 0.75 + 0.25</code>;</p>
<p><code>(R, G, B) = (r, g, b) * M</code></p>
<p>The idea is that since BC3 uses separate compression for the RGB and alpha blocks, the RGB and M signals can be independent. Additionally, the compressor can account for the RGB compression error. This will print warnings if any of the computed m values were greater than 1.0. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dacd61083f3787f211cdc3e7d27acf0bcb"></a>Format_ASTC_LDR_4x4&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 4x4. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6daa462932902c3804af0974ea419728caa"></a>Format_ASTC_LDR_5x4&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 5x4. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da69fa601cd97b38a974ad5a94a1f3f9a4"></a>Format_ASTC_LDR_5x5&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 5x5. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dae16bc6c24bb5c12f5b1bdfcfda621e49"></a>Format_ASTC_LDR_6x5&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 6x5. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da7eaa6f0a5231f4803526021a8706578c"></a>Format_ASTC_LDR_6x6&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 6x6. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da3a68b29ecfa982cccc6767d6689f0a5a"></a>Format_ASTC_LDR_8x5&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 8x5. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dab7f9c4ca1719ae5e4eceb3ce0a2f8901"></a>Format_ASTC_LDR_8x6&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 8x6. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dae931d404efcdffa4b2dbabf9fdf54228"></a>Format_ASTC_LDR_8x8&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 8x8. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da697ca508a97e9e064f7434863e39f41e"></a>Format_ASTC_LDR_10x5&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 10x5. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da7625882a2047accb75e68e3c3aa10ccf"></a>Format_ASTC_LDR_10x6&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 10x6. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da4c8c8b6ec09ff02cc4f3802b79ace3e0"></a>Format_ASTC_LDR_10x8&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 10x8. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6daf8842b25b9be7ace43116e155dcd18a6"></a>Format_ASTC_LDR_10x10&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 10x10. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6da8aae371759244af41fe3e77e7a904d10"></a>Format_ASTC_LDR_12x10&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 12x10. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a77ad50b0ef658f079f5ec637a287fd6dac03f729d1aede99d35414fd9b524a41a"></a>Format_ASTC_LDR_12x12&#160;</td><td class="fielddoc">
<p>ASTC - LDR - format, tile size 12x12. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7ea4cd82d5104d66e14f5524442c5f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a7ea4cd82d5104d66e14f5524442c5f5e">nvtt::InputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input formats. Used when creating an <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a> from an RGB/RGBA array. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7ea4cd82d5104d66e14f5524442c5f5eaf8b3af0719535e2e45599d0b20a463d2"></a>InputFormat_BGRA_8UB&#160;</td><td class="fielddoc">
<p>[0, 255] 8 bit uint </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7ea4cd82d5104d66e14f5524442c5f5ea2fcc1076f7eb98eb300757660fa8de07"></a>InputFormat_BGRA_8SB&#160;</td><td class="fielddoc">
<p>[-127, 127] 8 bit int </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7ea4cd82d5104d66e14f5524442c5f5ea351131926eee5bf0c0d0ed706699e2f0"></a>InputFormat_RGBA_16F&#160;</td><td class="fielddoc">
<p>16 bit floating point. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7ea4cd82d5104d66e14f5524442c5f5ea5c06b40c2edcfb0c948ebdc003c55a17"></a>InputFormat_RGBA_32F&#160;</td><td class="fielddoc">
<p>32 bit floating point. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7ea4cd82d5104d66e14f5524442c5f5ea7d8245786e1f39d2a9b8fb6baa2005c8"></a>InputFormat_R_32F&#160;</td><td class="fielddoc">
<p>Single channel 32 bit floating point. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a28d4701da3f4e6935956949dab69c479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a28d4701da3f4e6935956949dab69c479">nvtt::MipmapFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mipmap downsampling filters. Each of these can be customized using <code>filterWidth</code> and <code>params</code> when calling <a class="el" href="structnvtt_1_1_surface.html#ab85e9ae8132a60fcf923300687af2778" title="Resizes this surface to create the next mip in a mipmap chain. ">Surface::buildNextMipmap()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a28d4701da3f4e6935956949dab69c479a5aed6ac6d80b602d7bd7d8fd2d977697"></a>MipmapFilter_Box&#160;</td><td class="fielddoc">
<p>Box filter is quite good and very fast. It has some special paths for downsampling by exactly a factor of 2. <code>filterWidth</code> defaults to 0.5; <code>box(x)</code> is equal to 1 when <code>|x| &lt; filterWidth</code> and 0 otherwise. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a28d4701da3f4e6935956949dab69c479a484a5118a16886793c921a3f17c04a2c"></a>MipmapFilter_Triangle&#160;</td><td class="fielddoc">
<p>Triangle filter blurs the results too much, but that might be what you want. <code>filterWidth</code> defaults to 1.0; <code>triangle(x)</code> is equal to <code>filterWidth - |x|</code> when <code>|x| &lt; filterWidth</code> and 0 otherwise. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a28d4701da3f4e6935956949dab69c479ae4a53887c8ee06fd999f022eefa29c5e"></a>MipmapFilter_Kaiser&#160;</td><td class="fielddoc">
<p>Kaiser-windowed Sinc filter is the best downsampling filter, and close to a mathematically ideal windowing filter. If the window size is too large, it can introduce ringing.</p>
<p><code>filterWidth</code> controls the width of the Kaiser window. Larger values take longer to compute and include more oscillations of the sinc filter.</p>
<p><code>param[0]</code> (default: 4.0f) sets <code>alpha</code>, the sharpness of the Kaiser window. Higher values make the main lobe wider, but reduce sideband energy.</p>
<p><code>param[1]</code> (default: 1.0f) controls the frequency of the sinc filter. Higher values include higher frequencies.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Kaiser_window">https://en.wikipedia.org/wiki/Kaiser_window</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a445e3b46e43013ef66771e98f7b1e0ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a445e3b46e43013ef66771e98f7b1e0ba">nvtt::NormalTransform</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a normal transformation, used to store 3D (x, y, z) normals in 2D (x, y). </p>
<p>We define these in terms of their 2D -&gt; 3D reconstructions, since their transformations are the inverse of the reconstructions. Most require z &gt;= 0.0f.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvtt_1_1_surface.html#aa9589b42199086cf7fcb4f99a0bd243d" title="Applies a 3D-&gt;2D normal transformation, setting the z (blue) channel to 0. ">Surface::transformNormals()</a> </dd>
<dd>
<a class="el" href="structnvtt_1_1_surface.html#ad186ad17e1f204e00ecb54e018814cad" title="Reconstructs 3D normals from 2D transformed normals. ">Surface::reconstructNormals()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a445e3b46e43013ef66771e98f7b1e0baa7a435baa677e410f036ae06441229333"></a>NormalTransform_Orthographic&#160;</td><td class="fielddoc">
<p>Reconstructs the z component using <code>z = sqrt(1 - x^2 + y^2)</code>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a445e3b46e43013ef66771e98f7b1e0baac7ed9d9e81f80b4e11e1f53ab4f6f0f9"></a>NormalTransform_Stereographic&#160;</td><td class="fielddoc">
<p>Stereographic projection (like looking from the bottom of the sphere of normals and projecting points onto a plane at z = 1). Reconstructed using <code>d = 2/(1 + min(x^2 + y^2, 1)); return (x*d, y*d, d-1)</code>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a445e3b46e43013ef66771e98f7b1e0baa80b2a507b4e75a1febccfb2044cd86c8"></a>NormalTransform_Paraboloid&#160;</td><td class="fielddoc">
<p>Reconstructed using <code>normalize(x, y, 1 - min(x^2 + y^2, 1))</code>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a445e3b46e43013ef66771e98f7b1e0baa99c18c7689a8117272ab957e3bd78a4a"></a>NormalTransform_Quartic&#160;</td><td class="fielddoc">
<p>Reconstructed using <code>normalize(x, y, (1-x^2)(1-y^2))</code>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#accbc2d4c0396fc4e6d75d19e435c88ed">nvtt::PixelType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pixel value types. </p>
<p>These are used for Format_RGB: they indicate how the output should be interpreted, but do not have any influence over the input. They are ignored for other compression modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88eda36283fd855802ab127337a9204a1abac"></a>PixelType_UnsignedNorm&#160;</td><td class="fielddoc">
<p>Used to indicate a DXGI_..._UNORM format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88edac5f45ced167de5441252bb48cedaae11"></a>PixelType_SignedNorm&#160;</td><td class="fielddoc">
<p>Not supported yet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88eda6f44a7d0693e3706916061221bc76724"></a>PixelType_UnsignedInt&#160;</td><td class="fielddoc">
<p>Not supported yet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88eda86f04728921c58b535e40d9b4e156123"></a>PixelType_SignedInt&#160;</td><td class="fielddoc">
<p>Not supported yet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88eda83f9ceb43bd9b001b835e39f08111db3"></a>PixelType_Float&#160;</td><td class="fielddoc">
<p>Used to indicate a DXGI_..._FLOAT format. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88edab8107297b020c703bc308794cbbdf6d5"></a>PixelType_UnsignedFloat&#160;</td><td class="fielddoc">
<p>Used to indicate a DXGI_..._UF16 format. Unused. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="accbc2d4c0396fc4e6d75d19e435c88edabb4c7c8a272083c0b14c7f8fdbf4f77b"></a>PixelType_SharedExp&#160;</td><td class="fielddoc">
<p>Shared exponent. Only supported for DXGI_FORMAT_R9G9B9E5_SHAREDEXP. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a5a4632cb59f63e6af3fc88fdfe5e44ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a5a4632cb59f63e6af3fc88fdfe5e44ee">nvtt::Quality</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quality modes. </p>
<p>These can be used to trade off speed of compression for lower error, and often selects the specific compression algorithm that will be used. Here's a table showing which (format, quality) combinations support CUDA acceleration:</p>
<table class="doxtable">
<tr>
<th>Quality </th><th>BC1 </th><th>BC1a </th><th>BC2 </th><th>BC3 </th><th>BC3n </th><th>RGBM </th><th>BC4 </th><th>BC5 </th><th>BC6 </th><th>BC7 </th><th>ASTC  </th></tr>
<tr>
<td>Fastest </td><td>Yes </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td>Normal </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>No </td><td>No </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td></tr>
<tr>
<td>Production </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No (slow) </td><td>Yes </td></tr>
<tr>
<td>Highest </td><td>Yes </td><td>Yes </td><td>Yes </td><td>Yes </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No (slow) </td><td>Yes </td></tr>
</table>
<p>See the documentation of the different compression functions in <a class="el" href="nvtt__lowlevel_8h.html">nvtt_lowlevel.h</a> for more information. </p>

</div>
</div>
<a class="anchor" id="a3607100ce561fdaa3859abd0f05878c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7">nvtt::ResizeFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Texture resizing filters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019"></a>ResizeFilter_Box&#160;</td><td class="fielddoc">
<p>Box filter. Fast, but produces nearest-neighbor artifacts when upsampling. </p><dl class="section see"><dt>See also</dt><dd>nvtt::MipmapFilter::MipmapFilter_Box </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3607100ce561fdaa3859abd0f05878c7a86e98691c89dc3a4cd0b24bb2fd173cd"></a>ResizeFilter_Triangle&#160;</td><td class="fielddoc">
<p>Triangle (tent) filter. It can blur the results too much, but that might be what you want. </p><dl class="section see"><dt>See also</dt><dd>nvtt::MipmapFilter::MipmapFilter_Triangle </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3607100ce561fdaa3859abd0f05878c7a6765919b82bb52e3384cd3b164347962"></a>ResizeFilter_Kaiser&#160;</td><td class="fielddoc">
<p>Kaiser-windowed Sinc filter. </p><dl class="section see"><dt>See also</dt><dd>nvtt::MipmapFilter::MipmapFilter_Kaiser </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3607100ce561fdaa3859abd0f05878c7ae014671bd84ab8296e2f1550f6afd7ee"></a>ResizeFilter_Mitchell&#160;</td><td class="fielddoc">
<p>Mitchell &amp; Netravali's two parameter cubic filter.</p>
<p><code>filterWidth</code> (default: 2.0f) can truncate the filter, but should usually be left at the default.</p>
<p><code>param[0]</code> (default: 1/3) sets B.</p>
<p><code>param[1]</code> (default: 2/3) sets C.</p>
<dl class="section see"><dt>See also</dt><dd>"Reconstruction Filters in Computer Graphics", SIGGRAPH 1988</dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters">https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a673a22796ec42ae50e14ab1ed6906bd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a673a22796ec42ae50e14ab1ed6906bd5">nvtt::RoundMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extents rounding mode. </p>
<p>Determines how to round sizes to different sets when shrinking an image.</p>
<p>For each of the PowerOfTwo modes, <code>maxExtent</code> is first rounded to the previous power of two.</p>
<p>Then all extents are scaled and truncated without changing the aspect ratio, using <code>s = max((s * maxExtent) / m, 1)</code>, where <code>m</code> is the maximum width, height, or depth.</p>
<p>If the texture is a cube map, the width and height are then averaged to make the resulting texture square.</p>
<p>Finally, extents are rounded to a set of possible sizes depending on this enum.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a73aebd76a0eef81407c40b5b93ee7c10" title="Geting the target extent for round-mode and texture-type. (New in NVTT 3.0) ">getTargetExtent()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a673a22796ec42ae50e14ab1ed6906bd5ae8a8417fa16eb6d657bec4a6a34a4eb5"></a>RoundMode_None&#160;</td><td class="fielddoc">
<p>Each extent is left as-is. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a673a22796ec42ae50e14ab1ed6906bd5a6c20fa585fc05a9fa78907cb75fd192e"></a>RoundMode_ToNextPowerOfTwo&#160;</td><td class="fielddoc">
<p>Each extent is rounded up to the next power of two. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a673a22796ec42ae50e14ab1ed6906bd5a62447741e676e7442edfa9a160f14be0"></a>RoundMode_ToNearestPowerOfTwo&#160;</td><td class="fielddoc">
<p>Each extent is rounded either up or down to the nearest power of two. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a673a22796ec42ae50e14ab1ed6906bd5aa11b8ae64e7890e5037d6984b96d14a5"></a>RoundMode_ToPreviousPowerOfTwo&#160;</td><td class="fielddoc">
<p>Each element is rounded down to the next power of two. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a30709ef62a9d666f2be7f34cce8e3b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94">nvtt::ToneMapper</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tone mapping functions. </p>
<dl class="section since"><dt>Since</dt><dd>NVTT 2.1 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a30709ef62a9d666f2be7f34cce8e3b94ae75755a83e2455024daa028f9997e142"></a>ToneMapper_Linear&#160;</td><td class="fielddoc">
<p>Colors inside [0,1)^3 are preserved; colors outside are tone mapped using (r', g', b') = (r, g, b)/max(r, g, b). This clamps colors to the RGB cube, but preserves hue. It is not invertible. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30709ef62a9d666f2be7f34cce8e3b94a4eac0b21fc9b9abaa609aaccbc8b692d"></a>ToneMapper_Reinhard&#160;</td><td class="fielddoc">
<p>Applies a Reinhard operator to each channel: c' = c / (c + 1). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30709ef62a9d666f2be7f34cce8e3b94ae212ae6b6b95ef74d99e8c294f0582a4"></a>ToneMapper_Reindhart&#160;</td><td class="fielddoc">
<p>Name for backwards compatibility. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94a4eac0b21fc9b9abaa609aaccbc8b692d" title="Applies a Reinhard operator to each channel: c&#39; = c / (c + 1). ">ToneMapper_Reinhard</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30709ef62a9d666f2be7f34cce8e3b94a88b4b1bc1882ee68b7148e3e36fe155f"></a>ToneMapper_Halo&#160;</td><td class="fielddoc">
<p>Applies an exponential tone mapper to each channel: c' = 1 - 2^(-c). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a30709ef62a9d666f2be7f34cce8e3b94ab9ee3d3f346369d1097532952c3f0baf"></a>ToneMapper_Lightmap&#160;</td><td class="fielddoc">
<p>Same as <a class="el" href="namespacenvtt.html#a30709ef62a9d666f2be7f34cce8e3b94ae75755a83e2455024daa028f9997e142">ToneMapper_Linear</a>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae939a4f095a98e5176153b81dba28321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#ae939a4f095a98e5176153b81dba28321">nvtt::ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value type of the input images. The input buffer will use the same value type as the input images </p>

</div>
</div>
<a class="anchor" id="a04c40c16cdcde3c6c3f2e7081777a146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenvtt.html#a04c40c16cdcde3c6c3f2e7081777a146">nvtt::WrapMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap modes. Specifies how to handle coordinates outside the typical image range. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a04c40c16cdcde3c6c3f2e7081777a146ad11969ec5e66b90e4c7c55a2aa2542f0"></a>WrapMode_Clamp&#160;</td><td class="fielddoc">
<p>Coordinates are clamped, moving them to the closest coordinate inside the image. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a04c40c16cdcde3c6c3f2e7081777a146aa974b2999b7a9ca5a0cbf5ebf52ecea9"></a>WrapMode_Repeat&#160;</td><td class="fielddoc">
<p>The image is treated as if it repeats on both axes, mod each dimension. For instance, for a 4x4 image, (5, -2) wraps to (1, 2). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a04c40c16cdcde3c6c3f2e7081777a146a550cb72f50d0b0571a2db0badfb44083"></a>WrapMode_Mirror&#160;</td><td class="fielddoc">
<p>Coordinates are treated as if they reflect every time they pass through the center of an edge texel. For instance, for a 10x10 image, (8, 0), (10, 0), (26, 0), and (28, 0) all mirror to (8, 0). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3c5eb0a19f8d66f6c9f5cf33f335c32f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_astc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ASTC format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. This supports 4 quality levels on both the CPU and GPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">qualityLevel</td><td>The quality level, 0, 1, 2, or 3. Higher quality levels produce less compression error, but take longer.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25b2a51a1949426c7f860c52c7561b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_astc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ASTC format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This supports 4 quality levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">qualityLevel</td><td>The quality level, 0, 1, 2, or 3. Higher quality levels produce less compression error, but take longer.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f678e13767228c68dfcad1da61e8b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_ati2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ATI2 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a393f3f5de7cdefa79e31b095384b6e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_ati2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to ATI2 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05bd68f7ce315c0c26124793512bc6ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC1 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. This applies to both CPU and GPU compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9e0e41149b87bd6c5d3f327ac7a0a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC1 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Compression always happens on the GPU, so CUDA must be available.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bd3ed1c285fc5e6c146cc9de88937bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC1a format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No fast-mode algorithm for the GPU is available, so when <code>fast_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. In this case, slow-mode GPU compression may be faster than fast-mode CPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for fast-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>fast_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61eefb6c30a92e72d297f3bf2fe39f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc1a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC1a format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU slow-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb08b8c7f7030e7473187ff5e986294f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC2 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No fast-mode algorithm for the GPU is available, so when <code>fast_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. In this case, slow-mode GPU compression may be faster than fast-mode CPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for fast-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>fast_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ae6bd44be0539af54582d5dd5aa88a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC2 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU slow-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac335a276d5f79af2a762d76988e661ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No fast-mode algorithm for the GPU is available, so when <code>fast_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. In this case, slow-mode GPU compression may be faster than fast-mode CPU compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">fast_mode</td><td>If true, uses a faster but lower-quality compressor; otherwise, uses a slower but higher-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for fast-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>fast_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaad95872eab2e29b5b4a7721c4a2b961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU slow-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad69901604f7f6e6e1acb0486ad5db001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3_rgbm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3 - rgbm format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. This method is currently CPU-only and has 1 quality level. See <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da3623a3b6e315c7cd908dd4ea78b68c58">nvtt::Format_BC3_RGBM</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output in CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab82056d5ee5c0f852135d8cd6bab149e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc3n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC3n format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. This method is currently CPU-only, but supports 3 quality levels</p><ul>
<li>0, 1, and 2. See <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da841bbc25f933d81b4a43c851c5440c64" title="DX10 - BC3 (DXT5) normal format for improved compression, storing a normal (x, y, z) as (1...">nvtt::Format_BC3n</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">qualityLevel</td><td>Higher quality levels produce less compression error, but take longer to compress. Can be 0, 1, or 2.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output in CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c370ed199a91ca69c4c01c9f6daed39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4U format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa76314c0b925a24e3f509e4a212668ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4U format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab15a4c506eb1c3b5ad89249ef3e8e340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4S format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3e7a48139329817c6b6acc3ae875c03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc4s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC4S format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c96f1d819b4c61b42d537c102080c32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5U format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dfc0444515b1304ab9a1cb6eb9ff5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5U format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e4d632aa6c550b8b461f4343125fe77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5S format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3ea7d013fca07b16f48745ad67b1e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc5s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC5S format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebd712c6a68534c161e2e20fa3967663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc6h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_signed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC6H format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">is_signed</td><td>If true, compresses to the BC6S format, instead of BC6U.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74857405343d8148e3aa8a840f5d9c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc6h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_signed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC6H format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">is_signed</td><td>If true, compresses to the BC6S format, instead of BC6U.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc828476883ed40499d01622d2a0873f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc7 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html">CPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGpu</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC7 format from <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">CPUInputBuffer</a>. No slow-mode algorithm for the GPU is available, so when <code>slow_mode</code> is true this ignores <code>useGPU</code> and compresses on the CPU. The slow-mode CPU compressor is particularly slow in this case (as it searches though a very large space of possibilities), so fast-mode compression is recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in CPU memory.</td></tr>
    <tr><td class="paramname">slow_mode</td><td>If true, uses a slower but higher-quality compressor; otherwise, uses a faster but lower-quality compressor. Also overrides <code>useGPU</code> if true and uses the CPU for slow-mode compression.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">useGpu</td><td>Whether to run the compression algorithm on the GPU as opposed to the CPU. See note on <code>slow_mode</code>.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80dbdb09bbe3f2702bad846d90b69578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> nvtt::nvtt_encode_bc7 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html">GPUInputBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>imageHasAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_device_mem</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvtt_1_1_timing_context.html">nvtt::TimingContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface for compressing to BC7 format from <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">GPUInputBuffer</a>, always using GPU compression. This method has only one quality level, corresponding to CPU fast-mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Constant reference to input in GPU memory.</td></tr>
    <tr><td class="paramname">imageHasAlpha</td><td>Specifies that some pixels in the image have an alpha value less than 1.0f. If false, this makes compression slightly faster. It's still valid to set it to true even if the image is opaque.</td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output: CUDA device pointer if <code>to_device_mem</code> is true, and a pointer to CPU memory otherwise.</td></tr>
    <tr><td class="paramname">to_device_mem</td><td>Specifies that <code>output</code> is a CUDA device pointer, rather than a pointer to CPU memory.</td></tr>
    <tr><td class="paramname">tc</td><td>Timing context for recording performance information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4331c366610258762f80c8a3d7ee6910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvtt__lowlevel_8h.html#a888e0c50df09fc78a88844abfbf23f97">NVTT_API</a> void nvtt::useCurrentDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells NVTT to always use an application-set device rather than selecting its own. </p>
<p>By default, NVTT functions such as <a class="el" href="namespacenvtt.html#a07e1ba1bbab69167fca20f080ca9ce8e" title="Check if CUDA is supported by the run-time environment. ">nvtt::isCudaSupported()</a> and <a class="el" href="structnvtt_1_1_context.html" title="Compression context. ">nvtt::Context()</a> can choose a device and call cudaSetDevice(). Calling this function will prevent NVTT from calling cudaSetDevice(), and will make it use the currently set device instead. The application must then call cudaSetDevice() before calling NVTT functions, and whenever it wants to change the device subsequent NVTT functions will use.</p>
<p>For instance, this may be useful when managing devices on multi-GPU systems. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
