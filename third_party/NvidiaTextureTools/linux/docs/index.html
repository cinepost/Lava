<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>nvtt: NVTT 3 - API Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvtt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NVTT 3 - API Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>NVTT 3 is a library that can be used to compress image data and files into compressed texture formats, and to handle compressed and uncompressed images.</p>
<p>In NVTT 3, most compression algorithms and image processing algorithms can be accelerated by the GPU. These have CPU fallbacks for GPUs without support for CUDA.</p>
<p>The NVTT 3 C++ APIs consist of 2 headers. The high-level APIs are defined in <a class="el" href="nvtt_8h.html">nvtt/nvtt.h</a>. These APIs include image I/O, image processing, and general interfaces for image compression - the main functionality.</p>
<p>The low-level APIs are exposed through <a class="el" href="nvtt__lowlevel_8h.html">nvtt/nvtt_lowlevel.h</a>. This includes individual functions for compressing to each of the supported texture formats. In addition, these allow inputs and outputs to each be located on the CPU or GPU, and give more freedom with regard to image layouts. The high-level APIs are based on the low-level APIs.</p>
<p>In addition, a C wrapper for other compilers and programming languages is available through nvtt/nvtt_wrapper.h.</p>
<p>Here we give some examples with reference code of using the high-level and low-level APIs. More samples covering a range of features will be available at <a href="https://github.com/nvpro-samples/nvtt_samples">https://github.com/nvpro-samples/nvtt_samples</a>.</p>
<h2>Using the high-level APIs</h2>
<h3>Compressing a single file</h3>
<p>First, create an <a class="el" href="structnvtt_1_1_context.html" title="Compression context. ">nvtt::Context</a>. Contexts are used both for global settings and for controlling the compression process:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_context.html">nvtt::Context</a> context;</div><div class="line">context.<a class="code" href="structnvtt_1_1_context.html#a8191fdc9c711b060013edccd0162f02f">enableCudaAcceleration</a>(<span class="keyword">true</span>);</div><div class="line"><span class="comment">// Now all context compression will be CUDA-accelerated if any system GPU supports it.</span></div></div><!-- fragment --><p>In NVTT, we use <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a> to store a single uncompressed image. <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a> has a method <a class="el" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5" title="Loads texture data from a file. ">nvtt::Surface::load()</a>, which can be used to load an image file. A typical image loading process looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div><div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5">load</a>(inputFileName);</div></div><!-- fragment --><p>Then, we set up compression options using <a class="el" href="structnvtt_1_1_compression_options.html" title="Compression options. This class describes the desired compression format and other compression settin...">nvtt::CompressionOptions</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_compression_options.html">nvtt::CompressionOptions</a> compressionOptions;</div><div class="line"><span class="comment">// Compress to 4-channel, 8-bit-per-pixel BC3:</span></div><div class="line">compressionOptions.<a class="code" href="structnvtt_1_1_compression_options.html#ad5cef3af27cb8944f54d475c3bbcc89c">setFormat</a>(<a class="code" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6dac8ee0455899fe6fde42300df20aaf282">nvtt::Format_BC3</a>);</div></div><!-- fragment --><p>See <a class="el" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6d" title="Supported block-compression formats, including compressor variants. ">nvtt::Format</a> for all compression formats.</p>
<p>Next, we say how to write the compressed data using <a class="el" href="structnvtt_1_1_output_options.html" title="Output Options. ">nvtt::OutputOptions</a>. The simplest case is to assign a filename directly:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_output_options.html">nvtt::OutputOptions</a> outputOptions;</div><div class="line">outputOptions.<a class="code" href="structnvtt_1_1_output_options.html#a3d3cc71dba3ca05dabaa73d3a91bd52d">setFileName</a>(outputFileName);</div></div><!-- fragment --><p>For more dedicated control of the output stream, you may want to derive a subclass of <a class="el" href="structnvtt_1_1_output_handler.html" title="Inheritable interface for outputting data. ">nvtt::OutputHandler</a>, then use <a class="el" href="structnvtt_1_1_output_options.html#ad7ac0c427c87129350bdd0ba65970cf1" title="Set output handler. ">nvtt::OutputOptions::setOutputHandler</a> to redirect the output:</p>
<div class="fragment"><div class="line">MyOutputHandler outputHandler;</div><div class="line">outputOptions.<a class="code" href="structnvtt_1_1_output_options.html#ad7ac0c427c87129350bdd0ba65970cf1">setOutputHandler</a>(&amp;outputHandler);</div></div><!-- fragment --><p>When the above setup is complete, we compress the image using <a class="el" href="structnvtt_1_1_context.html" title="Compression context. ">nvtt::Context</a>.</p>
<div class="fragment"><div class="line">context.<a class="code" href="structnvtt_1_1_context.html#ab5a846f7f8ca7dc50a00737539ad254e">outputHeader</a>(image, 1, compressionOptions, outputOptions); <span class="comment">// output DDS header</span></div><div class="line">context.<a class="code" href="structnvtt_1_1_context.html#a8a49498fc569a9e4590882bf679ed3ec">compress</a>(image, 0, 0, compressionOptions, outputOptions); <span class="comment">// output compressed image</span></div></div><!-- fragment --><h3>Loading SurfaceSets from DDS files</h3>
<p>DDS files can contain multiple cube map faces and mipmap levels. To load these surfaces, you may want to use <a class="el" href="structnvtt_1_1_surface_set.html" title="Surface-set struct for convenience of handling multi-level texture files such as DDS, currently only supporting reading. ">nvtt::SurfaceSet</a> as the loader:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface_set.html">nvtt::SurfaceSet</a> images;</div><div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a62cbe48d4ec1498d5e5edebb800cb2d8">loadDDS</a>(ddsFileName);</div></div><!-- fragment --><p>Then you can use <a class="el" href="structnvtt_1_1_surface_set.html#a2810b0e8b80c4401bbcccf556c314ede" title="Get a surface at specified face and mip level. ">nvtt::SurfaceSet::GetSurface()</a> to extract each individual <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image = images.<a class="code" href="structnvtt_1_1_surface_set.html#a2810b0e8b80c4401bbcccf556c314ede">GetSurface</a>(face, mip);</div></div><!-- fragment --><p>or:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div><div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a2810b0e8b80c4401bbcccf556c314ede">GetSurface</a>(face, mip, image);</div></div><!-- fragment --><h3>Compressing multiple files faster</h3>
<p>For batch processing of multiple files, we use <a class="el" href="structnvtt_1_1_batch_list.html" title="Structure defining a list of inputs to be compressed. ">nvtt::BatchList</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_batch_list.html">nvtt::BatchList</a> batchList;</div></div><!-- fragment --><p>Instead of compressing each image one-by-one, now we first append all images to the <code>batchList</code> container. Each image has its own output handler (e.g. to write to multiple files):</p>
<div class="fragment"><div class="line">batchList.<a class="code" href="structnvtt_1_1_batch_list.html#abdaeb97d4bb24d975f9a5354c120995b">Append</a>(image, 0 <span class="comment">/*face*/</span>, 0<span class="comment">/*mip*/</span>, outputOptions1);</div><div class="line">batchList.<a class="code" href="structnvtt_1_1_batch_list.html#abdaeb97d4bb24d975f9a5354c120995b">Append</a>(image2, 0 <span class="comment">/*face*/</span>, 0<span class="comment">/*mip*/</span>, outputOptions2);</div><div class="line">...</div></div><!-- fragment --><p>Then we issue a single <code><a class="el" href="structnvtt_1_1_context.html#a8a49498fc569a9e4590882bf679ed3ec" title="Compress the Surface and write the compressed data to the output. ">nvtt::Context::compress</a></code> command to compress all the inputs:</p>
<div class="fragment"><div class="line">context.<a class="code" href="structnvtt_1_1_context.html#a8a49498fc569a9e4590882bf679ed3ec">compress</a>(batchList, compressionOptions);</div></div><!-- fragment --><p>When we do it this way, NVTT 3 will restructure the input images and exploit parallelism to the maximum extent when GPU compression is used, without needing to synchronize with the CPU between images. When there are a large number of small textures to compress with the same <a class="el" href="structnvtt_1_1_compression_options.html" title="Compression options. This class describes the desired compression format and other compression settin...">nvtt::CompressionOptions</a>, batch processing can dramatically increase the performance.</p>
<h3>Decompression</h3>
<p>The decompression routine is relatively straightforward. The function <a class="el" href="structnvtt_1_1_surface_set.html#a62cbe48d4ec1498d5e5edebb800cb2d8" title="Load surface set from DDS file. ">nvtt::SurfaceSet::loadDDS()</a> can be used to decode a DDS file. After the file is loaded, you can use <a class="el" href="structnvtt_1_1_surface_set.html#a9563de6e1048ae402af174d3461f70d2" title="Save an image at specified face and mip level (for decompression) ">nvtt::SurfaceSet::saveImage()</a> to output the result:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface_set.html">nvtt::SurfaceSet</a> images;</div><div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a62cbe48d4ec1498d5e5edebb800cb2d8">loadDDS</a>(ddsFileName);         </div><div class="line">images.<a class="code" href="structnvtt_1_1_surface_set.html#a9563de6e1048ae402af174d3461f70d2">saveImage</a>(outFileName,face,mip);</div></div><!-- fragment --><p>If you only have compressed data, but know the size and format, you can use <a class="el" href="structnvtt_1_1_surface.html#a4a687a3504eeba283366e36315904aeb" title="Set 2D surface values from an encoded data source. Same as setImage3D() with d=1. ...">nvtt::Surface::setImage2D()</a> or <a class="el" href="structnvtt_1_1_surface.html#a2aed8c61f05336b7eab8b2e1431ccc65" title="Set surface values from an encoded data source. ">nvtt::Surface::setImage3D()</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div><div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a4a687a3504eeba283366e36315904aeb">setImage2D</a>(<a class="code" href="namespacenvtt.html#a77ad50b0ef658f079f5ec637a287fd6da7504a001d01a2e3f1cda648f1e32676b">nvtt::Format_BC7</a>, width, height, data);</div></div><!-- fragment --><p>Note that decompression is currently not GPU accelerated.</p>
<h3>Image processing with <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a></h3>
<p>Some useful image processing routines are provided in <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a>. For example, a downsampling process looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_surface.html">nvtt::Surface</a> image;</div><div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a7162b072976c0134a3854df107c2b7d5">load</a>(inputFileName);</div><div class="line"></div><div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#aba4b4cc0b224540af8172c96080d1104">ToGPU</a>(); <span class="comment">// this enables GPU acceleration for the succeeding operations    </span></div><div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a80080f94846613535e5e7abbb61a8a7e">toLinearFromSrgb</a>(); <span class="comment">// resizing must be done in linear space</span></div><div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#aa8b2bd544a72fb7c60e0106c6f870893">resize</a>(newWidth, newHeight, newDepth, <a class="code" href="namespacenvtt.html#a3607100ce561fdaa3859abd0f05878c7ac608b4be1bb223cfd73e5aac2a002019">nvtt::ResizeFilter_Box</a>);</div><div class="line">image.<a class="code" href="structnvtt_1_1_surface.html#a17627047b1633a02c1d78e8de403bb6a">toSrgb</a>();</div></div><!-- fragment --><h2>Using the low-level APIs</h2>
<p>The low-level APIs are for compression only.</p>
<p>To use the low-level APIs, there is no need to create an <a class="el" href="structnvtt_1_1_context.html" title="Compression context. ">nvtt::Context</a> first, and images do not need to come from <a class="el" href="structnvtt_1_1_surface.html" title="A surface is one level of a 2D or 3D texture. ">nvtt::Surface</a>.</p>
<p>At the center of the low-level APIs, there are 2 buffer structs for storing the input image data. <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">nvtt::CPUInputBuffer</a> stores the data in host memory, and <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">nvtt::GPUInputBuffer</a> stores the data in device memory.</p>
<p>For each of the supported texture formats, there are 2 functions that compress textures into that format, each handling one buffer type. For functions using <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">nvtt::CPUInputBuffer</a>, there is a <code>useGpu</code> parameter to choose whether to use the GPU routine to compress it. For the function using <a class="el" href="structnvtt_1_1_g_p_u_input_buffer.html" title="Structure containing all the input images from device memory. The image data is reordered by tiles...">nvtt::GPUInputBuffer</a>, the compression is always done by the GPU. In both cases, the user can choose whether the output goes to host memory or device memory using the <code>to_device_mem</code> parameter.</p>
<p>A buffer can be created from one or more images in host memory or device memory. The user must reference each of the input images using the <a class="el" href="structnvtt_1_1_ref_image.html" title="Use this structure to reference each of the input images. ">nvtt::RefImage</a> structure.</p>
<p>Here's an example.</p>
<p>First, we use an external tool like stb_image to load a image file:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> chn;</div><div class="line"><span class="keywordtype">void</span> *p_img = stbi_load(<span class="stringliteral">&quot;my_texture.png&quot;</span>, &amp;img_in.width, &amp;img_in.height, &amp;chn, 4);</div></div><!-- fragment --><p>Second, we use <a class="el" href="structnvtt_1_1_ref_image.html" title="Use this structure to reference each of the input images. ">nvtt::RefImage</a> to reference this image:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_ref_image.html">nvtt::RefImage</a> img_in;</div><div class="line">img_in.<a class="code" href="structnvtt_1_1_ref_image.html#a28f7946a03f3887f191c097025fcc916">data</a> = p_img;</div><div class="line">img_in.<a class="code" href="structnvtt_1_1_ref_image.html#a775ea94efce207fea55be6fa1e0ce975">num_channels</a> = 4; <span class="comment">// stb_image always produces 4 channels</span></div><div class="line"><span class="keywordflow">if</span> (chn == 3)</div><div class="line">    img_in.<a class="code" href="structnvtt_1_1_ref_image.html#ad88dd307a6a2b111d6db66193c530f5c">channel_swizzle</a>[3] = nvtt::One; <span class="comment">// alpha channel set to 1 for opaque images</span></div></div><!-- fragment --><p>Third, we create a <a class="el" href="structnvtt_1_1_c_p_u_input_buffer.html" title="Structure containing all the input images from host memory. The image data is reordered by tiles...">nvtt::CPUInputBuffer</a> using the single <a class="el" href="structnvtt_1_1_ref_image.html" title="Use this structure to reference each of the input images. ">nvtt::RefImage</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structnvtt_1_1_c_p_u_input_buffer.html">nvtt::CPUInputBuffer</a> input_buf(&amp;img_in, nvtt::UINT8);</div><div class="line">free(p_img); <span class="comment">// data is copied and reordered, the original data can be freed</span></div></div><!-- fragment --><p>We then prepare a buffer for receiving compressed BC1 data:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>* outbuf = malloc(input_buf.NumTiles() * 8); <span class="comment">// BC1 uses 8 bytes/tile</span></div></div><!-- fragment --><p>Finally, call the BC1 compressing function:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacenvtt.html#a05bd68f7ce315c0c26124793512bc6ed">nvtt_encode_bc1</a>(input_buf, <span class="keyword">true</span> <span class="comment">/* fast_mode */</span>, outbuf, <span class="keyword">true</span> <span class="comment">/* useGpu */</span>, <span class="keyword">false</span> <span class="comment">/* to_device_mem */</span>);</div></div><!-- fragment --><p>The raw compressed blocks will then be stored in <code>outbuf</code>. The low-level APIs do not generate file headers (such as DDS file headers).</p>
<h2>Building with NVTT 3</h2>
<p>To add the dynamic build of NVTT 3 to a C++ application, link with <code>nvtt.lib</code> in the <code>lib/</code> folder, include <code><a class="el" href="nvtt_8h.html">nvtt/nvtt.h</a></code>, and copy <code>nvtt.dll</code> to the application output directory.</p>
<p>Example CMake applications using this process can be found at the <a href="https://github.com/nvpro-samples/nvtt3_samples.">online samples repository</a>; most of the work in the CMake file there is in locating the system's NVTT distribution.</p>
<p>The C++ API should be compatible with any MSVC 14x toolset. For other toolsets and other programming languages, please use the C wrapper in nvtt/nvtt_wrapper.h.</p>
<p>The dynamic build can also be <a href="https://docs.microsoft.com/en-us/cpp/build/reference/linker-support-for-delay-loaded-dlls">delay-loaded</a>.</p>
<h2>Considerations for CUDA compatibility</h2>
<p>The following notes are important for apps using CUDA elsewhere.</p>
<p>NVTT 3 uses the CUDA Runtime API, and certain functions such as <a class="el" href="structnvtt_1_1_context.html#a8191fdc9c711b060013edccd0162f02f" title="Enable CUDA acceleration; initializes CUDA if not already initialized. ">nvtt::Context::enableCudaAcceleration()</a> and <a class="el" href="namespacenvtt.html#a07e1ba1bbab69167fca20f080ca9ce8e" title="Check if CUDA is supported by the run-time environment. ">nvtt::isCudaSupported()</a> can choose a device and call <code>cudaSetDevice()</code> unless <a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910" title="Tells NVTT to always use an application-set device rather than selecting its own. ...">nvtt::useCurrentDevice()</a> has been called first. When using NVTT 3 with other CUDA functionality, we recommend doing two things:</p>
<ol type="1">
<li>Call <a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910" title="Tells NVTT to always use an application-set device rather than selecting its own. ...">nvtt::useCurrentDevice()</a> and <code>cudaSetDevice()</code> before any other NVTT 3 functions. Calling <a class="el" href="namespacenvtt.html#a4331c366610258762f80c8a3d7ee6910" title="Tells NVTT to always use an application-set device rather than selecting its own. ...">useCurrentDevice()</a> will prevent NVTT from choosing and changing the device. It only needs to be called once during the lifetime of the application.</li>
<li>When passing device pointers to NVTT, make sure the pointer refers to memory NVTT's device (and <a href="https://docs.nvidia.com/cuda/cuda-driver-api/driver-vs-runtime-api.html">runtime API context</a> if using the CUDA Driver API) can access. Similarly, when accessing data from device pointers returned from NVTT, make sure the current device (and context, if using the CUDA Driver API) can access allocations made by NVTT's device using the CUDA Runtime API. Device pointers are returned from <a class="el" href="structnvtt_1_1_surface.html#af1133a6735fa1f8cf6ee1d785539b021" title="Get a CUDA pointer to image data on the GPU, using the same layout as data(). If GPU data does not ex...">nvtt::Surface::gpuData()</a>, and used in the low-level GPU compression function API in <a class="el" href="nvtt__lowlevel_8h.html">nvtt_lowlevel.h</a>. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
