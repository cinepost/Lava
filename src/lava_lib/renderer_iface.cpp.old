#include <regex>

#include "renderer.h"
#include "renderer_iface.h"

#include "lava_utils_lib/ut_string.h"
#include "lava_utils_lib/logging.h"

#include "Falcor/Scene/MaterialX/MaterialX.h"


namespace lava {

static Display::SharedPtr loadDisplay(Display::DisplayType display_type) {
	auto pDisplay = Display::create(display_type);
	if(!pDisplay) {
        LLOG_ERR << "Unable to create display !!!";
		return nullptr;
    }

	return pDisplay;
}


RendererIface::RendererIface(std::shared_ptr<Renderer> pRenderer): mpRenderer(pRenderer) {
	// TODO: fill envmap with system wide variables
	mEnvmap["LAVA_HOME"] = getenv("LAVA_HOME");
}

RendererIface::~RendererIface() {
	if ( mpRenderer ) mpRenderer = nullptr;
	if ( mpDisplay ) mpDisplay=nullptr;
}

void RendererIface::setEnvVariable(const std::string& key, const std::string& value){
	LLOG_DBG << "setEnvVariable: " << key << " : " << value;
	mEnvmap[key] = value;
}

std::string RendererIface::getExpandedString(const std::string& s) {
	std::string result = s;

	for( auto const& [key, val] : mEnvmap )
		result = ut::string::replace(result, '$' + key, val);

	return result;
}

std::shared_ptr<SceneBuilder> RendererIface::getSceneBuilder(){ return mpRenderer->mpSceneBuilder; }

//bool RendererIface::openDisplay(const std::string& image_name, uint width, uint height) {
//	return mpRenderer->openDisplay(getExpandedString(image_name), width, height);
//}

bool RendererIface::addPlane(const PlaneData& plane_data) {
	return mpRenderer->addPlane(plane_data);
}

bool RendererIface::loadScriptFile(const std::string& file_name) {
	if(!mpRenderer->isInited()) {
		LLOG_ERR << "Unable lo load script! Renderer is NOT initialized !!!";
		return false;
	}
	return mpRenderer->loadScript(getExpandedString(file_name));
}

void RendererIface::loadDeferredScriptFile(const std::string& file_name) {
	mDeferredScriptFileNames.push_back(file_name);
}

bool RendererIface::initRenderer() {
	LLOG_DBG << "initRenderer";
	if(mpRenderer->isInited())
		return true;

	return mpRenderer->init();
}

void RendererIface::initRendererGlobalData(const GlobalData& global_data) {
	mGlobalData = global_data;
}

bool RendererIface::setDisplay(const DisplayData& display_data) {
	if(display_data.displayType == Display::DisplayType::__HYDRA__) return true;

	mpDisplay = loadDisplay(display_data.displayType);
	if(!mpDisplay) {
		return false;
	}


	// push display driver parameters
	for(auto const& parm: display_data.displayStringParameters)
		mpDisplay->setStringParameter(parm.first, parm.second);

	for(auto const& parm: display_data.displayIntParameters)
		mpDisplay->setIntParameter(parm.first, parm.second);

	for(auto const& parm: display_data.displayFloatParameters)
		mpDisplay->setFloatParameter(parm.first, parm.second);

	return true;
}

bool RendererIface::isRendererInitialized() const {
	return mpRenderer->isInited();
}

void RendererIface::renderFrame(const Renderer::FrameInfo& frame_info, const std::string& file_name) {
	LLOG_DBG << "RendererIfaceBase::renderFrame";
	if(!mpRenderer->isInited()) {
		LLOG_ERR << "Unable lo render frame! Renderer is NOT initialized !!!";
		return;
	}

	// load deferred scripts
	for( auto const& script_file_name: mDeferredScriptFileNames ) {
		if(!loadScriptFile(script_file_name)) {
			LLOG_ERR << "Error loading deferred script file " << script_file_name;
		}
	}

	if(!mpDisplay) {
		LLOG_ERR << "Renderer display is not ready !!!";
		return;
	}

	// Open display image
	uint hImage;

    if(mpDisplay) {
        mpDisplay->closeAll(); // close previous frame display images (if still opened)

        std::vector<Display::Channel> channels;
        channels.push_back({"r", Display::TypeFormat::FLOAT32});
        channels.push_back({"g", Display::TypeFormat::FLOAT32});
        channels.push_back({"b", Display::TypeFormat::FLOAT32});
        channels.push_back({"a", Display::TypeFormat::FLOAT32});
        

        if(!mpDisplay->openImage(file_name, frame_info.imageWidth, frame_info.imageHeight, channels, hImage)) {
            LLOG_FTL << "Unable to open image " << file_name << " !!!";
            return;
        }
    }


	{   // Frame rendeing
		
		mpRenderer->prepareFrame(frame_info);

		for(uint32_t sample_number = 0; sample_number < frame_info.imageSamples; sample_number++) {
			mpRenderer->renderSample();
		}
	}

	LLOG_DBG << "Senging renderd data to display";
    
	Renderer::AOVGeometry aov_geometry;
	if(!mpRenderer->queryAOVGeometry("AccumulatePass.output", aov_geometry)) {
		LLOG_FTL << "No AOV !!!";
		return;
	}

	Falcor::ResourceFormat outputResourceFormat;
	uint32_t outputChannelsCount = 0;

    std::vector<uint8_t> textureData;
    textureData.resize( aov_geometry.width * aov_geometry.height * aov_geometry.bytesPerPixel);
    
    if(!mpRenderer->getAOVImageData("AccumulatePass.output", textureData.data())) {
    	LLOG_ERR << "Error reading AOV texture data !!!";
    }
    
    try {
        if (!mpDisplay->sendImage(hImage, mGlobalData.imageWidth, mGlobalData.imageHeight, textureData.data())) {
            LLOG_ERR << "Error sending image to display !";
        }
    } catch (std::exception& e) {
        LLOG_ERR << "Error: " << e.what();
    }

    mpDisplay->closeImage(hImage);
	mpDisplay->closeDisplay();
}

bool RendererIface::addMaterialX(Falcor::MaterialX::UniquePtr pMaterialX) {
	return mpRenderer->addMaterialX(std::move(pMaterialX));
}

}  // namespace lava
