#ifndef SRC_FALCOR_SCENE_GEOMETRY_H_
#define SRC_FALCOR_SCENE_GEOMETRY_H_

#include <map>
#include <bitset>
#include <string>
#include <unordered_map>

#include "Falcor/Core/API/VAO.h"
#include "Falcor/Scene/Animation/Animatable.h"
#include "Falcor/Scene/Material/Material.h"
#include "Falcor/Scene/Scene.h"
#include "VertexAttrib.slangh"
#include "Falcor/Scene/Lights/LightLinker.h"


namespace Falcor {

namespace Geometry {

static constexpr uint32_t kInvalidExportedID = Animatable::kInvalidNode;    ///< Largest uint32 value (-1)
static constexpr uint32_t kInvalidNodeID = Animatable::kInvalidNode;

struct InstanceShadingSpec {
    bool        isMatte = false;
    bool        fixShadowTerminator = true;
    bool        biasAlongNormal = false;
    bool        doubleSided = true;
    bool        subdivide = false;
};

struct InstanceVisibilitySpec {
    bool        visibleToPrimaryRays = true;
    bool        visibleToShadowRays = true;
    bool        visibleToDiffuseRays = true;
    bool        visibleToReflectionRays = true;
    bool        visibleToRefractionRays = true;
    bool        receiveShadows = true;
    bool        receiveSelfShadows = true;
};

/** This struct holds per instance arbitrary data that might be used map renderer internal mesh data to one was exported from some software.
     *  We can use either all of the fields, some fields or none of them at all. Depends on a task.
     */

struct InstanceExportedDataSpec {
    uint32_t    id = kInvalidExportedID;         ///< Some id that was generated by any content creation software, exporter, etc... Id given by any dcc software.
    std::string name;                            ///< Same concept as exportedID, but shit time it's a string ...  
};

struct MeshInstanceCreationSpec {
    InstanceExportedDataSpec*   pExportedDataSpec = nullptr;
    InstanceVisibilitySpec*     pVisibilitySpec = nullptr;
    InstanceShadingSpec*        pShadingSpec = nullptr;
    Material::SharedPtr         pMaterialOverride = nullptr;

    LightLinker::StringList     isolatedLightNames;   ///< Light names list that illuminates this instance. If empty then instance illuinated by all active scene lights. 
};

struct MeshInstanceSpec {
    uint32_t    nodeId;
    uint32_t    materialId;
    bool        overrideMaterial = false;

    uint32_t    lightSetIndex = LightLinker::kInvalidLightSetIndex;
    uint32_t    shadowTraceSetIndex = LightLinker::kInvalidTraceSetIndex;
    uint32_t    reflectTraceSetIndex = LightLinker::kInvalidTraceSetIndex;
    uint32_t    refractTraceSetIndex = LightLinker::kInvalidTraceSetIndex;

    InstanceExportedDataSpec    exported;
    InstanceShadingSpec         shading;
    InstanceVisibilitySpec      visibility;

    uint32_t perPrimMaterialIndicesOffset = 0;      ///< Offest into per-primitive material indices array. 
    uint32_t perPrimMaterialIndicesCount  = 0;      ///< Number of per-primitive materials. 

    std::vector<int32_t> perPrimitiveMaterialIDsData;
    
    bool hasMultipleMaterials() const { return perPrimMaterialIndicesCount > 0; }
};

struct PrimitiveAdjacency {
    std::vector<uint32_t> counts;
    std::vector<uint32_t> offsets;
    std::vector<uint32_t> data;

    bool _valid; // Set by Adjacency data builder!
    
    bool isValid() const { return _valid && !counts.empty() && !offsets.empty() && !data.empty(); }
};

struct MeshletSpec {
    MeshletType type = MeshletType::Triangles;
    std::vector<uint32_t>   vertices;             ///< Meshlet vertices that point to global scene vertex data.
    std::vector<uint8_t>    indices;              ///< Indices of a primitive verices.
    std::vector<uint32_t>   primitiveIndices;     ///< Primitive indices in a global scene buffer.

    AABB                    aabbLocal;            ///< Axis aligned bounding box relative to object aabb;
    Vao::Topology           topology = Vao::Topology::TriangleList;

    void reset() {
        vertices.clear();
        indices.clear();
        primitiveIndices.clear();
    }

    uint32_t primitiveCount() const {
        return static_cast<uint32_t>(indices.size() / ((topology == Vao::Topology::QuadList) ? 4 : 3));
    }

    uint32_t vertexCount() const {
        return static_cast<uint32_t>(vertices.size());
    }

    uint32_t indexCount() const {
        return static_cast<uint32_t>(indices.size());
    }
};

struct MeshSpec {
    std::string name;
    Vao::Topology topology = Vao::Topology::Undefined;
    uint32_t materialId = 0;                    ///< Global material ID.
    uint32_t staticVertexOffset = 0;            ///< Offset into the shared 'staticData' array. This is calculated in createGlobalBuffers().
    uint32_t staticVertexCount = 0;             ///< Number of static vertices.
    uint32_t perPrimMaterialIndicesOffset = 0;  ///< Offest into per-primitive material indices array. 
    uint32_t perPrimMaterialIndicesCount  = 0;  ///< Number of per-primitive materials. 
    uint32_t skinningVertexOffset = 0;          ///< Offset into the shared 'skinningData' array. This is calculated in createGlobalBuffers().
    uint32_t skinningVertexCount = 0;           ///< Number of skinned vertices.
    uint32_t prevVertexOffset = 0;              ///< Offset into the shared `prevVertices` array. This is calculated in createGlobalBuffers().
    uint32_t prevVertexCount = 0;               ///< Number of previous vertices stored. This can be the static or skinned vertex count depending on animation type.
    uint32_t indexOffset = 0;                   ///< Offset into the shared 'indexData' array. This is calculated in createGlobalBuffers().
    uint32_t indexCount = 0;                    ///< Number of indices, or zero if non-indexed.
    uint32_t vertexCount = 0;                   ///< Number of vertices.
    uint32_t skeletonNodeID = kInvalidNodeID;   ///< Node ID of skeleton world transform. Forwarded from Mesh struct.
    bool use16BitIndices = false;               ///< True if the indices are in 16-bit format.
    bool hasSkinningData = false;               ///< True if mesh has dynamic vertices.
    bool isStatic = false;                      ///< True if mesh is non-instanced and static (not dynamic or animated).
    bool isFrontFaceCW = false;                 ///< Indicate whether front-facing side has clockwise winding in object space.
    bool isDisplaced = false;                   ///< True if mesh has displacement map.
    bool isAnimated = false;                    ///< True if mesh has vertex animations.
    AABB boundingBox;                           ///< Mesh bounding-box in object space.
    std::vector<MeshInstanceSpec> instances;    ///< All instances of this mesh.

    // Pre-processed vertex data.
    std::vector<uint32_t> indexData;    ///< Vertex indices in either 32-bit or 16-bit format packed tightly, or empty if non-indexed.
    std::vector<StaticVertexData> staticData;
    std::vector<SkinningVertexData> skinningData;
    std::vector<int32_t> perPrimitiveMaterialIDsData;

    // Meshlets data.
    std::vector<MeshletSpec> meshletSpecs;

    // Primitives adjacency data.
    PrimitiveAdjacency adjacency;

    // Thread sync.
    mutable std::mutex mMutex;

    MeshSpec() {};

    MeshSpec(const MeshSpec& spec);

    MeshSpec& operator=(const MeshSpec& o);

    size_t   getHostMemUsage() const {
        return  instances.size() * sizeof(MeshInstanceSpec) + 
                indexData.size() * sizeof(uint32_t) +
                staticData.size() * sizeof(StaticVertexData) +
                skinningData.size() * sizeof(SkinningVertexData) +
                perPrimitiveMaterialIDsData.size() * sizeof(int32_t);
    }

    uint32_t getTriangleCount() const {
        assert(topology == Vao::Topology::TriangleList);
        return (indexCount > 0 ? indexCount : vertexCount) / 3;
    }

    uint32_t getPrimitivesCount() const {
        switch(topology) {
            case Vao::Topology::TriangleList:
                return (indexCount > 0 ? indexCount : vertexCount) / 3;
            case Vao::Topology::QuadList:
                return (indexCount > 0 ? indexCount : vertexCount) / 4;
            default:
                return 0;
        }
    }

    uint32_t getIndex(const size_t i) const {
        assert(i < indexCount);
        return use16BitIndices ? reinterpret_cast<const uint16_t*>(indexData.data())[i] : indexData[i];
    }

    bool isSkinned() const {
        return hasSkinningData;
    }

    bool isDynamic() const {
        return isSkinned() || isAnimated;
    }

    bool hasMultipleMaterials() const {
        return perPrimMaterialIndicesCount > 0;
    }

    bool hasMeshlets() const {
        return !meshletSpecs.empty();
    }
};

/** Mesh description
*/
struct Mesh {
    using AttribName = std::string;
    using StringList = std::vector<std::string>;
    using AttributesStrings = std::unordered_map<AttribName, StringList>;

    enum class AttributeFrequency {
        None,
        Constant,       ///< Constant value for mesh. The element count must be 1.
        Uniform,        ///< One value per face. The element count must match `faceCount`.
        Vertex,         ///< One value per vertex. The element count must match `vertexCount`.
        FaceVarying,    ///< One value per vertex per face. The element count must match `indexCount`.
    };

    template<typename T>
    struct Attribute {
        const T* pData = nullptr;
        AttributeFrequency frequency = AttributeFrequency::None;
    };

    std::string name;                           ///< The mesh's name.
    uint32_t faceCount = 0;                     ///< The number of primitives the mesh has.
    uint32_t vertexCount = 0;                   ///< The number of vertices the mesh has.
    uint32_t indexCount = 0;                    ///< The number of indices the mesh has.
    const uint32_t* pIndices = nullptr;         ///< Array of indices. The element count must match `indexCount`. This field is required.
    Vao::Topology topology = Vao::Topology::Undefined; ///< The primitive topology of the mesh
    Material::SharedPtr pMaterial;              ///< The mesh's material. Can't be nullptr.

    Attribute<float3> positions;                ///< Array of vertex positions. This field is required.
    Attribute<float3> normals;                  ///< Array of vertex normals. This field is required.
    Attribute<float4> tangents;                 ///< Array of vertex tangents. This field is optional. If set to nullptr, or if BuildFlags::UseOriginalTangentSpace is not set, the tangent space will be generated using MikkTSpace.
    Attribute<float> curveRadii;                ///< Array of vertex curve radii. This field is optional.
    Attribute<float2> texCrds;                  ///< Array of vertex texture coordinates. This field is optional. If set to nullptr, all texCrds will be set to (0,0).
    Attribute<uint4> boneIDs;                   ///< Array of bone IDs. This field is optional. If it's set, that means that the mesh is animated, in which case boneWeights is required.
    Attribute<float4> boneWeights;              ///< Array of bone weights. This field is optional. If it's set, that means that the mesh is animated, in which case boneIDs is required.
    Attribute<int32_t> materialIDs;

    AttributesStrings attributesStrings;


    bool isFrontFaceCW = false;                 ///< Indicate whether front-facing side has clockwise winding in object space.
    bool useOriginalTangentSpace = false;       ///< Indicate whether to use the original tangent space that was loaded with the mesh. By default, we will ignore it and use MikkTSpace to generate the tangent space.
    bool mergeDuplicateVertices = true;         ///< Indicate whether to merge identical vertices and adjust indices.
    uint32_t skeletonNodeId = Animatable::kInvalidNode;     ///< For skinned meshes, the node ID of the skeleton's world transform. If set to -1, the skeleton is based on the mesh's own world position (Assimp behavior pre-multiplies instance transform).

    template<typename T>
    uint32_t getAttributeIndex(const Attribute<T>& attribute, uint32_t face, uint32_t vert) const {
        switch (attribute.frequency) {
            case AttributeFrequency::Constant:
                return 0;
            case AttributeFrequency::Uniform:
                return face;
            case AttributeFrequency::Vertex:
                return pIndices[face * 3 + vert];
            case AttributeFrequency::FaceVarying:
                return face * 3 + vert;
            default:
                should_not_get_here();
        }
        return Scene::kInvalidIndex;
    }

    const AttributesStrings& getAttributesStrings() const { return attributesStrings; }

    StringList* attributeStringList(const std::string& name, bool createMissing = false) {
        auto it = attributesStrings.find(name);
        if(it != attributesStrings.end()) return &it->second;
        
        if(createMissing) {
            attributesStrings.insert(std::make_pair(name, StringList()));
            return &attributesStrings[name];
        }
        return nullptr;
    }

    StringList* materialAttributeStrings(bool createMissing) {
        return attributeStringList("material", createMissing);
    }

    bool hasMultipleMaterials() const {
        return materialIDs.pData != nullptr;
    }

    template<typename T>
    T get(const Attribute<T>& attribute, uint32_t index) const {
        if (attribute.pData) {
            return attribute.pData[index];
        }
        return T{};
    }

    template<typename T>
    T get(const Attribute<T>& attribute, uint32_t face, uint32_t vert) const {
        if (attribute.pData) {
            return get(attribute, getAttributeIndex(attribute, face, vert));
        }
        return T{};
    }

    template<typename T>
    size_t getAttributeCount(const Attribute<T>& attribute) {
        switch (attribute.frequency) {
            case AttributeFrequency::Constant:
                return 1;
            case AttributeFrequency::Uniform:
                return faceCount;
            case AttributeFrequency::Vertex:
                return vertexCount;
            case AttributeFrequency::FaceVarying:
                return 3 * faceCount;
            default:
                should_not_get_here();
        }
        return 0;
    }


    float3 getPosition(uint32_t face, uint32_t vert) const { return get(positions, face, vert); }
    float3 getNormal(uint32_t face, uint32_t vert) const { return get(normals, face, vert); }
    float4 getTangent(uint32_t face, uint32_t vert) const { return get(tangents, face, vert); }
    float2 getTexCrd(uint32_t face, uint32_t vert) const { return get(texCrds, face, vert); }
    float getCurveRadii(uint32_t face, uint32_t vert) const { return get(curveRadii, face, vert); }

    struct Vertex {
        float3 position;
        float3 normal;
        float4 tangent;
        float2 texCrd;
        float curveRadius;
        uint4 boneIDs;
        float4 boneWeights;
    };

    struct VertexAttributeIndices {
        uint32_t positionIdx;
        uint32_t normalIdx;
        uint32_t tangentIdx;
        uint32_t texCrdIdx;
        uint32_t curveRadiusIdx;
        uint32_t boneIDsIdx;
        uint32_t boneWeightsIdx;
    };


    Vertex getVertex(uint32_t face, uint32_t vert) const {
        Vertex v = {};
        v.position = get(positions, face, vert);
        v.normal = get(normals, face, vert);
        v.tangent = get(tangents, face, vert);
        v.texCrd = get(texCrds, face, vert);
        v.curveRadius = get(curveRadii, face, vert);
        v.boneIDs = get(boneIDs, face, vert);
        v.boneWeights = get(boneWeights, face, vert);
        return v;
    }

    Vertex getVertex(const VertexAttributeIndices& attributeIndices) {
        Vertex v = {};
        v.position = get(positions, attributeIndices.positionIdx);
        v.normal = get(normals, attributeIndices.normalIdx);
        v.tangent = get(tangents, attributeIndices.tangentIdx);
        v.texCrd = get(texCrds, attributeIndices.texCrdIdx);
        v.curveRadius = get(curveRadii, attributeIndices.curveRadiusIdx);
        v.boneIDs = get(boneIDs, attributeIndices.boneIDsIdx);
        v.boneWeights = get(boneWeights, attributeIndices.boneWeightsIdx);
        return v;
    }

    VertexAttributeIndices getAttributeIndices(uint32_t face, uint32_t vert) {
        VertexAttributeIndices v = {};
        v.positionIdx = getAttributeIndex(positions, face, vert);
        v.normalIdx = getAttributeIndex(normals, face, vert);
        v.tangentIdx = getAttributeIndex(tangents, face, vert);
        v.texCrdIdx = getAttributeIndex(texCrds, face, vert);
        v.curveRadiusIdx = getAttributeIndex(curveRadii, face, vert);
        v.boneIDsIdx = getAttributeIndex(boneIDs, face, vert);
        v.boneWeightsIdx = getAttributeIndex(boneWeights, face, vert);
        return v;
    }

    bool hasBones() const {
        return boneWeights.pData || boneIDs.pData;
    }
};

}  // namespace Geometry

}  // namespace Falcor

#endif  // SRC_FALCOR_SCENE_GEOMETRY_H_
