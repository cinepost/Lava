#include <unordered_set>

#include "Falcor/Scene/MeshletBuilder.h"


namespace Falcor {


MeshletBuilder::MeshletBuilder() {

};

MeshletBuilder::UniquePtr MeshletBuilder::create() {
  return std::move(UniquePtr(new MeshletBuilder()));
}

void MeshletBuilder::generateMeshlets(SceneBuilder::ProcessedMesh& mesh) {
  if(mesh.indexData.empty()) {
    LLOG_WRN << "Meshlets generation for non-indexed mesh \"" << mesh.name << "\" not supported yet !!!";
  	return;
  }

  auto& meshletSpecs = mesh.meshletSpecs;
	meshletSpecs.clear();

  static constexpr uint32_t maximumMeshletTriangleIndices = MESHLET_MAX_POLYGONS_COUNT * 3u;
  static constexpr uint32_t maximumMeshletQuadIndices = MESHLET_MAX_POLYGONS_COUNT * 4u;
  
  if (mesh.use16BitIndices) assert(mesh.indexCount <= mesh.indexData.size() * 2);

  uint16_t const* pMesh16BitIndicesData = reinterpret_cast<uint16_t const*>(mesh.indexData.data());

  uint32_t mesh_start_index = 0;

  while(mesh_start_index < mesh.indexCount) {
    std::vector<uint32_t> meshletVertices;
    std::vector<uint32_t> meshletPrimIndices;
    std::vector<uint8_t>  meshletIndices;

    std::set<uint32_t> pointIndices; // this set is used to avoid having duplicate vertices within meshlet
    std::vector<uint3> triangles;

    SceneBuilder::MeshletSpec meshletSpec = {};
    meshletSpec.type = MeshletType::Triangles;

    if(mesh.use16BitIndices) {
      LLOG_WRN << "16 bit indices !!!!!!!!!!";
    }

    // Run through mesh indices until we reach max number of elements (points or tris)
    for(uint32_t i = mesh_start_index; i < mesh.indexCount; i+=3) {
      //LLOG_WRN << "! " << mesh.indexData[i] << " " << mesh.indexData[i+1] << " " << mesh.indexData[i+2];

      uint32_t mIdx0, mIdx1, mIdx2;

      if (mesh.use16BitIndices) {
        mIdx0 = static_cast<uint32_t>(pMesh16BitIndicesData[i]);
        mIdx1 = static_cast<uint32_t>(pMesh16BitIndicesData[i+1]);
        mIdx2 = static_cast<uint32_t>(pMesh16BitIndicesData[i+2]);
      } else {
        mIdx0 = mesh.indexData[i];
        mIdx1 = mesh.indexData[i+1];
        mIdx2 = mesh.indexData[i+2];
      }

      std::set<uint32_t>::iterator it0 = pointIndices.find(mIdx0);
      std::set<uint32_t>::iterator it1 = pointIndices.find(mIdx1);
      std::set<uint32_t>::iterator it2 = pointIndices.find(mIdx2);

      const bool newV0 = it0 == pointIndices.end();
      const bool newV1 = it1 == pointIndices.end();
      const bool newV2 = it2 == pointIndices.end();

      const size_t new_vertices_count = (newV0 ? 1 : 0) + (newV1 ? 1 : 0) + (newV2 ? 1 : 0);

      const bool maxVerticesPerMeshletReached = ((pointIndices.size() + new_vertices_count) > MESHLET_MAX_VERTICES_COUNT);
      const bool maxIndicesPerMeshletReached  = ((meshletSpec.type == MeshletType::Triangles) && ((meshletIndices.size() + 3) > maximumMeshletTriangleIndices)) ||
                                                ((meshletSpec.type == MeshletType::Quads) && ((meshletIndices.size() + 4) > maximumMeshletQuadIndices));

      if (maxVerticesPerMeshletReached || maxIndicesPerMeshletReached) {
        LLOG_TRC << (maxIndicesPerMeshletReached ? std::string("Maximum meshlet polys reached for mesh ") : std::string("Maximum meshlet vertices reached for mesh ")) << mesh.name;
        mesh_start_index = i;
        break;
      }

      // These are per meshlet local indices. Guaranteed not to exceed value of 255 (by default we use max 128 elements)
      meshletIndices.push_back(std::distance(pointIndices.begin(), newV0 ? pointIndices.insert(mIdx0).first : it0));
      meshletIndices.push_back(std::distance(pointIndices.begin(), newV1 ? pointIndices.insert(mIdx1).first : it1));
      meshletIndices.push_back(std::distance(pointIndices.begin(), newV2 ? pointIndices.insert(mIdx2).first : it2));

      meshletPrimIndices.push_back(i / 3u);
      mesh_start_index += 3;
    }

    for(auto pi : pointIndices) {
    	meshletVertices.push_back(pi);
      //LLOG_WRN << pi;
    }

    meshletSpec.vertices = std::move(meshletVertices);
    meshletSpec.indices = std::move(meshletIndices);
    meshletSpec.primitiveIndices = std::move(meshletPrimIndices);
    LLOG_TRC << "Generated meshlet spec " << meshletSpecs.size() << " for mesh \"" << mesh.name << "\". " << meshletSpec.vertices.size() << 
      " vertices. " << meshletSpec.indices.size() << " indices.";

    meshletSpecs.push_back(std::move(meshletSpec));
  }
  LLOG_DBG << "Generated " << meshletSpecs.size() << " meshlet specs for mesh \"" << mesh.name;
}

}  // namespace Falcor
