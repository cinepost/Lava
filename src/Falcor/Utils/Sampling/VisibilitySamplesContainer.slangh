#pragma once
#include "Utils/Math/MathConstants.slangh"
#include "Utils/HostDeviceShared.slangh"

#ifndef HOST_CODE
import Utils.Math.PackedFormats;
import Utils.Math.FormatConversion;
#endif

#define VISIBILITY_CONTAINER_INFOBUFFER_FLAGS_LOCATION                          0
#define VISIBILITY_CONTAINER_INFOBUFFER_OPAQUE_SAMPLES_COUNT_LOCATION           1
#define VISIBILITY_CONTAINER_INFOBUFFER_TRANSPARENT_SAMPLES_COUNT_LOCATION      2
#define VISIBILITY_CONTAINER_INFOBUFFER_HAS_TRANSPARENT_SAMPLES_LOCATION        3
#define VISIBILITY_CONTAINER_INFOBUFFER_TRANSPARENT_LISTS_COUNT_LOCATION        4
#define VISIBILITY_CONTAINER_INFOBUFFER_MAX_TRANSPARENT_LAYERS_COUNT_LOCATION   5

#define VISIBILITY_CONTAINER_INFOBUFFER_SORT_OPAQUE_COUNTER_LOCATION            6
#define VISIBILITY_CONTAINER_INFOBUFFER_SORT_TRANSP_COUNTER_LOCATION            7

#ifndef VISIBILITY_SAMPLES_CONTAINER_MAX_TRANSPARENT_SAMPLES_COUNT_PP
#define VISIBILITY_SAMPLES_CONTAINER_MAX_TRANSPARENT_SAMPLES_COUNT_PP 1
#endif

BEGIN_NAMESPACE_FALCOR

/* TODO: */
// depth  32 bit
// offset 24 bit
// alpha  8 bit


struct TransparentVisibilitySampleData {
    uint64_t        depth;
    float           alpha;
    uint            nextSampleOffset;

#ifdef HOST_CODE
    uint4           packedHitInfo;
#else // !HOST_CODE
    PackedHitInfo   packedHitInfo;
#endif

#ifdef HOST_CODE
    TransparentVisibilitySampleData() {
        depth = 0;
        alpha = 0.0f;
        nextSampleOffset = UINT32_MAX;
        packedHitInfo = uint4(0);
    }
#else
    __init() {
        depth = 0;
        alpha = 0.0f;
        nextSampleOffset = UINT32_MAX;
        packedHitInfo = {};
    }
#endif
};

struct OpaqueVisibilitySample {
    #ifdef HOST_CODE
        uint4           packedHitInfo;
    #else // !HOST_CODE
        PackedHitInfo   packedHitInfo;
    #endif

    uint4               packedCombinedNormal;

#ifndef HOST_CODE
    bool hasCombinedNormal() CONST_FUNCTION {
        return !any(packedCombinedNormal != uint4(0));
    }

    float3 getNormalW() CONST_FUNCTION {
        return {unpackSnorm16(packedCombinedNormal.x >> 16), unpackSnorm16(packedCombinedNormal.y >> 16), unpackSnorm16(packedCombinedNormal.z >> 16)};
    }

    float3 getFaceNormalW() CONST_FUNCTION {
        return {unpackSnorm16(packedCombinedNormal.x & 0x0000ffff), unpackSnorm16(packedCombinedNormal.y & 0x0000ffff), unpackSnorm16(packedCombinedNormal.z & 0x0000ffff)};
    }

    HitInfo getHitInfo() CONST_FUNCTION {
        return HitInfo(packedHitInfo);
    }

    __init() {
        packedHitInfo = uint4(0);
        packedCombinedNormal = uint4(0);
    }

    __init(PackedHitInfo _hitInfo, uint4 _packedCombinedNormal) {
        packedHitInfo = _hitInfo;
        packedCombinedNormal = _packedCombinedNormal;
    }
#endif
};

struct TransparentVisibilitySample {
    #ifdef HOST_CODE
        uint4           packedHitInfo;
    #else // !HOST_CODE
        PackedHitInfo   packedHitInfo;
    #endif

    uint4               packedCombinedNormal;
    float16_t           alpha;
    float16_t           visibilityWeight;

#ifndef HOST_CODE
    bool hasCombinedNormal() CONST_FUNCTION {
        return !any(packedCombinedNormal != uint4(0));
    }

    float3 getNormalW() CONST_FUNCTION {
        return {unpackSnorm16(packedCombinedNormal.x >> 16), unpackSnorm16(packedCombinedNormal.y >> 16), unpackSnorm16(packedCombinedNormal.z >> 16)};
    }

    float3 getFaceNormalW() CONST_FUNCTION {
        return {unpackSnorm16(packedCombinedNormal.x & 0x0000ffff), unpackSnorm16(packedCombinedNormal.y & 0x0000ffff), unpackSnorm16(packedCombinedNormal.z & 0x0000ffff)};
    }

    HitInfo getHitInfo() CONST_FUNCTION {
        return HitInfo(packedHitInfo);
    }

    __init() {
        packedHitInfo = uint4(0);
        packedCombinedNormal = uint4(0);
    }
#endif
};

END_NAMESPACE_FALCOR


enum class VisibilitySamplesContainerFlags : uint32_t {
    None = 0x0,

    OpaqueSamplesSorted          = 0x1,   ///< Indicates that opaque samples are sorted into separate buffer.
    TransparentRootsSorted       = 0x2,   ///< Indicates that transparent roots are sorted.
    TransparentListsSorted       = 0x4,   ///< Indicates that transparent sample lists are sorted.
    HasCombinedNormals           = 0x8,
};
