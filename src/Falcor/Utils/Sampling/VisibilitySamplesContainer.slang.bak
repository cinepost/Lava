#include "Utils/Math/MathConstants.slangh"
#include "Utils/HostDeviceShared.slangh"
#include "Utils/Sampling/VisibilitySamplesContainer.slangh"

import Utils.Math.FormatConversion;

__exported import Scene.SceneTypes;
__exported import Scene.HitInfo;


#ifndef VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
#define VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP 0
#endif

/** This struct represents the GPU-side visibility samples container system.
*/
struct VisibilitySamplesContainer {
    uint2       resolution;
    uint        resolution1D;
    uint        maxTransparentSamplesCountPP;    ///< Maximum number of transparent surface per pixel.
    uint        maxTransparentSamplesCount; 
    bool        limitTransparentSamplesCountPP;
    float       alphaThresholdMin;
    float       alphaThresholdMax;    
    uint32_t    flags;                      
    
    // Opaque samples data
    RWStructuredBuffer<PackedHitInfo>               opaqueVisibilitySamplesBuffer;
    RWStructuredBuffer<uint>                        opaqueVisibilitySamplesPositionBufferPP;

    // Transparent samples data
    RWStructuredBuffer<uint>                        rootTransparentSampleOffsetBufferPP;
    RWStructuredBuffer<uint>                        transparentVisibilitySamplesPositionBufferPP;
    RWStructuredBuffer<uint>                        transparentVisibilitySamplesCountBufferPP;
    RWStructuredBuffer<TransparentVisibilitySample> transparentVisibilitySamplesBuffer;

    // Opaque depth buffer data
    Texture2D<uint>                                 depthBuffer;

    RWStructuredBuffer<uint>                        infoBuffer;

    uint fetchTransparentSamplesList(uint pixelOffset, out SortedTransparentVisibilitySample samples[VISIBILITY_SAMPLES_CONTAINER_MAX_TRANSPARENT_SAMPLES_COUNT_PP]) {
        if(!hasTransparentSamples()) return 0;

        // Fetch first transparent sample
        TransparentVisibilitySample rootTransparentSample;
        
    #if VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
        uint sampleOffset = rootTransparentSampleOffsetBufferPP[pixelOffset];
        if(sampleOffset == UINT32_MAX) return 0;
        rootTransparentSample = transparentVisibilitySamplesBuffer[pixelOffset * maxTransparentSamplesCountPP];
    #else
        if(!readRootTransparentVisibilitySample(pixelOffset, rootTransparentSample)) return 0;
    #endif

        samples[0].hitInfo = rootTransparentSample.hitInfo;
        samples[0].alpha = rootTransparentSample.alpha;

        // Fetch remaining transparent samples
    #if VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
        uint nextSampleOffset = pixelOffset * maxTransparentSamplesCountPP + 1;
    #else
        uint nextSampleOffset = rootTransparentSample.nextSampleOffset;
    #endif

        uint samplesCount = 1;
        while(nextSampleOffset != UINT32_MAX && samplesCount < transparentSamplesCount(pixelOffset)) {            
            samples[samplesCount].hitInfo = transparentVisibilitySamplesBuffer[nextSampleOffset].hitInfo;
            samples[samplesCount++].alpha = transparentVisibilitySamplesBuffer[nextSampleOffset].alpha;

        #if VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
            nextSampleOffset++;
        #else
            nextSampleOffset = transparentVisibilitySamplesBuffer[nextSampleOffset].nextSampleOffset;
        #endif
        }

        return samplesCount;
    }

    uint fetchSortedTransparentSamplesList(uint pixelOffset, out SortedTransparentVisibilitySample samples[VISIBILITY_SAMPLES_CONTAINER_MAX_TRANSPARENT_SAMPLES_COUNT_PP]) {
        uint samplesCount = fetchTransparentSamplesList(pixelOffset, samples);

        if(!isTransparentListsSorted()) {
            // TODO: Sort samples list in-place
        }

        return samplesCount;
    }

    uint fetchSortedTransparentSamplesList2D(uint2 pixelPos, out SortedTransparentVisibilitySample samples[VISIBILITY_SAMPLES_CONTAINER_MAX_TRANSPARENT_SAMPLES_COUNT_PP]) {
        if(!hasTransparentSamples()) return 0;

        // Fetch first transparent sample
        TransparentVisibilitySample rootTransparentSample;
        
        if(!readRootTransparentVisibilitySample2D(pixelPos, rootTransparentSample)) return 0;
        
        samples[0].hitInfo = rootTransparentSample.hitInfo;
        samples[0].alpha = rootTransparentSample.alpha;

        // Fetch remaining transparent samples
        uint nextSampleOffset = rootTransparentSample.nextSampleOffset;

        uint samplesCount = 1;
        while(nextSampleOffset != UINT32_MAX && samplesCount < maxTransparentSamplesCountPP) {            
            samples[samplesCount].hitInfo = transparentVisibilitySamplesBuffer[nextSampleOffset].hitInfo;
            samples[samplesCount++].alpha = transparentVisibilitySamplesBuffer[nextSampleOffset].alpha;
            nextSampleOffset = transparentVisibilitySamplesBuffer[nextSampleOffset].nextSampleOffset;
        }

        if(!isTransparentListsSorted()) {
            // TODO: Sort samples in-place
        }

        return samplesCount;
    }

    HitInfo readOpaqueHit(uint pixelOffset) {
        return HitInfo(opaqueVisibilitySamplesBuffer[pixelOffset]);
    }

    HitInfo readOpaqueHit2D(uint2 pixelPos) {
        if(isOpaqueSorted()) return {};

        uint pixelOffset = pixelPos.x + pixelPos.y * resolution.x;
        return readOpaqueHit(pixelOffset);
    }

    void invalidateOpaqueSample(uint pixelOffset) {
        opaqueVisibilitySamplesBuffer[pixelOffset] = {};
    }

    void writeOpaqueHit2D(uint2 pixelPos, const HitInfo hit) {
        if(isOpaqueSorted()) return;

        uint pixelOffset = pixelPos.x + pixelPos.y * resolution.x;
        opaqueVisibilitySamplesBuffer[pixelOffset] = hit.getData();

        //uint tmp;
        //InterlockedExchange(opaqueVisibilitySamplesPositionBufferPP[pixelOffset], u2x16to32(uint16_t2(pixelPos)), tmp);
    }

    bool readRootTransparentVisibilitySample(uint pixelOffset, inout TransparentVisibilitySample sample) {
        uint sampleOffset = rootTransparentSampleOffsetBufferPP[pixelOffset];
        if(sampleOffset == UINT32_MAX) return false;

        #if VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
            sampleOffset += pixelOffset * maxTransparentSamplesCountPP;
        #endif

        sample = transparentVisibilitySamplesBuffer[sampleOffset];
        return true;
    }

    bool readRootTransparentVisibilitySample2D(uint2 pixelPos, inout TransparentVisibilitySample sample) {
        if(isTransparentRootsSorted()) {
            return false;
        }

        uint pixelOffset = pixelPos.x + pixelPos.y * resolution.x;
        return readRootTransparentVisibilitySample(pixelOffset, sample);
    }

    TransparentVisibilitySample readTransparentVisibilitySample(uint offset) {
        return transparentVisibilitySamplesBuffer[offset];
    }

    void writeTransparentHit(uint2 pixelPos, const HitInfo hit, float alpha, uint64_t depth) {
        if(pixelPos.x >= resolution.x || pixelPos.y >= resolution.y) return;
        if(!hit.isValid() || alpha < alphaThresholdMin) return;

        if(alpha > alphaThresholdMax) {
            writeOpaqueHit2D(pixelPos, hit);
            return;
        }

        infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_HAS_TRANSPARENT_SAMPLES_LOCATION] = 1;

        TransparentVisibilitySample transparentSample = {};
        transparentSample.hitInfo = hit.getData();
        transparentSample.depth = depth;
        transparentSample.alpha = alpha;

        uint pixelOffset = pixelPos.x + pixelPos.y * resolution.x;
        uint curSampleOffset, newSampleOffset;
        uint curSamplesCount = 0;
        
        // total transparent samples counter
        InterlockedAdd(infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_TRANSPARENT_SAMPLES_COUNT_LOCATION], 1, curSampleOffset);

    #if VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
    
        InterlockedAdd(rootTransparentSampleOffsetBufferPP[pixelOffset], 1, curSampleOffset);
        newSampleOffset = ((curSampleOffset + 1) % maxTransparentSamplesCountPP) + __pixelBucketOffset(pixelPos);
        if(curSampleOffset != UINT32_MAX) curSampleOffset = (curSampleOffset % maxTransparentSamplesCountPP) + __pixelBucketOffset(pixelPos);

    #else
        if(curSampleOffset >= maxTransparentSamplesCount) return;
        newSampleOffset = curSampleOffset;
        
        InterlockedExchange(rootTransparentSampleOffsetBufferPP[pixelOffset], newSampleOffset, curSampleOffset);
        InterlockedAdd(transparentVisibilitySamplesCountBufferPP[pixelOffset], 1, curSamplesCount);
    
    #endif

        transparentSample.nextSampleOffset = curSampleOffset;
        transparentVisibilitySamplesBuffer[newSampleOffset] = transparentSample;

        InterlockedMax(infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_MAX_TRANSPARENT_LAYERS_COUNT_LOCATION], min((curSamplesCount + 1), maxTransparentSamplesCountPP));
    }

    bool isOpaqueSorted() CONST_FUNCTION {
        return (flags & (uint)VisibilitySamplesContainerFlags::OpaqueSamplesSorted) != 0;
        //return (infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_FLAGS_LOCATION] & (uint)VisibilitySamplesContainerFlags::OpaqueSamplesSorted) != 0;
    }

    void setOpaqueSorted() {
        infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_FLAGS_LOCATION] |= (uint32_t)VisibilitySamplesContainerFlags::OpaqueSamplesSorted;
    }

    bool isTransparentRootsSorted() CONST_FUNCTION {
        return (flags & (uint)VisibilitySamplesContainerFlags::TransparentRootsSorted) != 0;
        //return (infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_FLAGS_LOCATION] & (uint)VisibilitySamplesContainerFlags::TransparentRootsSorted) != 0;
    }

    void setTransparentRootsSorted() {
        infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_FLAGS_LOCATION] |= (uint32_t)VisibilitySamplesContainerFlags::TransparentRootsSorted;
    }

    bool isTransparentListsSorted() CONST_FUNCTION {
        return (flags & (uint)VisibilitySamplesContainerFlags::TransparentListsSorted) != 0;
        //return (infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_FLAGS_LOCATION] & (uint)VisibilitySamplesContainerFlags::TransparentListsSorted) != 0;
    }

    void setTransparentListsSorted() {
        infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_FLAGS_LOCATION] |= (uint32_t)VisibilitySamplesContainerFlags::TransparentListsSorted;
    }

    bool hasTransparentSamples() CONST_FUNCTION {
        return infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_HAS_TRANSPARENT_SAMPLES_LOCATION];
    }

    uint opaqueSamplesCount() CONST_FUNCTION {
        if(isOpaqueSorted()) {
            return infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_OPAQUE_SAMPLES_COUNT_LOCATION];
        }
        return resolution1D;
    }

    uint transparentListsCount() CONST_FUNCTION {
        if(isTransparentRootsSorted()) {
            return infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_TRANSPARENT_LISTS_COUNT_LOCATION];
        }
        return resolution1D;
    }

    uint transparentSamplesCount() CONST_FUNCTION {
        return infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_TRANSPARENT_SAMPLES_COUNT_LOCATION];
    }

    uint maxTransparentLayersCount() CONST_FUNCTION {
        return infoBuffer[VISIBILITY_CONTAINER_INFOBUFFER_MAX_TRANSPARENT_LAYERS_COUNT_LOCATION];
    }

    uint2 offsetToPixelPos(uint pixelOffset) CONST_FUNCTION {
        return { pixelOffset % resolution.x, pixelOffset / resolution.x };
    }

    uint2 opaquePixelPos(uint pixelOffset) CONST_FUNCTION {
        if(isOpaqueSorted()) {
            return (uint2)u32to2x16(opaqueVisibilitySamplesPositionBufferPP[pixelOffset]);
        }
        return { pixelOffset % resolution.x, pixelOffset / resolution.x };
    }

    uint2 transparentPixelPos(uint pixelOffset) CONST_FUNCTION {
        if(isTransparentRootsSorted()) {
            return (uint2)u32to2x16(transparentVisibilitySamplesPositionBufferPP[pixelOffset]);
        }
        return { pixelOffset % resolution.x, pixelOffset / resolution.x };
    }

    uint transparentSamplesCount(uint pixelOffset) CONST_FUNCTION {
#if VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
        // When strict samples count pp is enabled we can use offset buffer as simple samples counter
        return min(rootTransparentSampleOffsetBufferPP[pixelOffset] + 1, maxTransparentSamplesCountPP);
#else
        return transparentVisibilitySamplesCountBufferPP[pixelOffset];
#endif
    }

    uint transparentSamplesCount2D(uint2 pixelPos) CONST_FUNCTION {
        uint pixelOffset = pixelPos.x + pixelPos.y * resolution.x;
        return transparentSamplesCount(pixelOffset);
    }

    float getAlphaThresholdMin() CONST_FUNCTION {
        return alphaThresholdMin;
    }

    float getAlphaThresholdMax() CONST_FUNCTION {
        return alphaThresholdMax;
    }

    uint __pixelBucketOffset(uint2 pixelPos) CONST_FUNCTION {
#if VISIBILITY_SAMPLES_CONTAINER_LIMIT_TRANSPARENT_SAMPLES_COUNT_PP
        return (pixelPos.x + pixelPos.y * resolution.x) * maxTransparentSamplesCountPP;
#else
        return 0;
#endif
    }
};

#ifdef VISIBILITY_CONTAINER_PARAMETER_BLOCK
// Declare parameter block used for shader reflection.
ParameterBlock<VisibilitySamplesContainer> gVisibilitySamplesContainer;
void main() {};
#endif